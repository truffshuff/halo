#Define Project
substitutions:
  name: halo
  version: "25.10.26.1402"
  device_description: ${name} - v${version}.

# Include modular packages
packages:
  page_registry: !include packages/page-registry.yaml

  # BLE packages (optional - see packages/README-BLE-INTEGRATION.md)
  # OPTION 1: BLE DISABLED (default) - Use BLE stubs (recommended):
  ble_stubs: !include packages/ble-stubs.yaml
  # OPTION 2: BLE ENABLED - Comment out the line above and uncomment this:
  # ble_core: !include packages/ble-core.yaml
  # WARNING: Enabling BLE can cause heap exhaustion and crashes!
  # Reduce LVGL buffer_size to 15-20% if enabling BLE
  # Monitor heap usage via memory_stats package

  vertical_clock: !include packages/vertical-clock-core.yaml
  wireguard: !include packages/wireguard.yaml
  wifi_display: !include packages/wifi-display.yaml
  wireguard_display: !include packages/wireguard-display.yaml
  memory_stats: !include packages/memory-stats.yaml

  # Weather packages (optional - see packages/README-WEATHER-INTEGRATION.md)
  # OPTION 1: Weather ENABLED (default) - Use these 3 packages:
  weather_core: !include packages/weather-core.yaml
  weather_sensors: !include packages/weather-sensors.yaml
  weather_fonts_text: !include packages/weather-fonts-text.yaml
  # OPTION 2: Weather DISABLED - Comment out the 3 lines above and uncomment this:
  # weather_stubs: !include packages/weather-stubs.yaml
  # Note: Also comment out weather-pages.yaml in the lvgl display section below
  # Note: Also comment out weather options in the "Default Page" select

  # Time update script - choose one:
  # With WireGuard (SNTP/HA switching): !include packages/time-update-wireguard.yaml
  # Without WireGuard (HA only): !include packages/time-update-basic.yaml
  time_update: !include packages/time-update-wireguard.yaml

  # AirQ packages (optional - see packages/README-AIRQ-INTEGRATION.md)
  # OPTION 1: AirQ ENABLED (default) - Use these 2 packages:
  airq: !include packages/airq-core.yaml
  airq_display: !include packages/airq-display.yaml
  # OPTION 2: AirQ DISABLED - Comment out the 2 lines above and uncomment this:
  # airq_stubs: !include packages/airq-stubs.yaml
  # Note: Also comment out airq-display.yaml in the lvgl pages section below
  # Note: Also remove "AirQ" option from the "Default Page" select if desired

  # WiFi packages (optional - see packages/README-WIFI-INTEGRATION.md)
  # OPTION 1: WiFi ENABLED (default) - Use wifi-core package:
  wifi_core: !include packages/wifi-core.yaml
  # OPTION 2: WiFi DISABLED - Comment out the line above and uncomment this:
  # wifi_stubs: !include packages/wifi-stubs.yaml
  # Note: Also comment out wifi-display and lvgl-wifi page includes below
  # Note: Also remove "WiFi" option from the "Default Page" select if desired

psram:
  mode: octal
  # speed: 120MHz

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  cpu_frequency: 240MHz
  
  framework:
    type: esp-idf
    advanced:
      enable_idf_experimental_features: true
    # platform_version: 6.9.0
    # version: 5.3.1

external_components:
  - source: github://truffshuff/esphome-components
    components: [axs15231, sy6970]

  - source: github://pr#7770 # RMT driver, remove rmt_channel when using esp-idf
    components: [ remote_base, remote_receiver, remote_transmitter, esp32_rmt, esp32_rmt_led_strip ]
    refresh: 0s

spi:
  id: lily_spi
  type: quad
  clk_pin: 17
  data_pins:
    - 13
    - 18
    - 21
    - 14

captive_portal:

logger:
  level: INFO

globals:
  - id: cycleCounter
    type: int
    restore_value: no
    initial_value: '0'
  - id: temp_unit_changed
    type: bool
    initial_value: "true"
  - id: last_touch_time
    type: int
    initial_value: '0'
  - id: auto_page_rotation_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: auto_page_rotation_interval
    type: int
    restore_value: yes
    initial_value: '30'  # Default 30 seconds
  - id: last_auto_rotation_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  # Page rotation settings - which pages are included
  # Note: page_rotation_AirQ_enabled is defined in airq-core.yaml or airq-stubs.yaml
  # Note: page_rotation_wifi_enabled is defined in wifi-core.yaml or wifi-stubs.yaml
  # Note: page_rotation_vertical_clock_enabled is defined in vertical-clock-core.yaml
  # Page rotation order (1-5, 0 means disabled)
  # Note: page_rotation_AirQ_order is defined in airq-core.yaml or airq-stubs.yaml
  # Note: page_rotation_wifi_order is defined in wifi-core.yaml or wifi-stubs.yaml
  # Note: page_rotation_vertical_clock_order is defined in vertical-clock-core.yaml
  - id: default_page_index
    type: int
    restore_value: yes
    initial_value: '0'
  - id: current_page_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ota_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'  # Set to true during OTA or other critical operations
  - id: time_update_last_started
    type: int
    restore_value: no
    initial_value: '0'
  - id: time_update_last_duration
    type: int
    restore_value: no
    initial_value: '0'
  - id: time_update_last_text
    type: std::string
    restore_value: no
    initial_value: ""
  - id: time_update_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'
  # Note: colon_blink_state is defined in vertical-clock-core.yaml
  - id: display_backlight_is_on
    type: bool
    restore_value: no
    initial_value: 'true'
  # Sensor UI update batching
  - id: sensor_ui_dirty
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_sensor_ui_update
    type: uint32_t
    restore_value: no
    initial_value: '0'

switch:
  - platform: template
    name: "Auto Page Rotation"
    id: auto_page_rotation
    icon: mdi:rotate-3d-variant
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(auto_page_rotation_enabled) = true;'
      - logger.log: "Auto page rotation enabled"
    on_turn_off:
      - lambda: 'id(auto_page_rotation_enabled) = false;'
      - logger.log: "Auto page rotation disabled"
  - platform: template
    name: "Startup Light Blink"
    id: startup_light_blink
    icon: mdi:lightbulb
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"

  # Page rotation selection switches
  # Note: "24h Clock Format" switch is defined in vertical-clock-core.yaml
  # Note: "Clock Colon Blink" switch is defined in vertical-clock-core.yaml
  # Note: "Page Rotation: Vertical Clock Page" switch is defined in vertical-clock-core.yaml
  # Note: "Page Rotation: AirQ Page" switch is defined in airq-core.yaml
  # Note: "Page Rotation: WiFi Page" switch is defined in wifi-core.yaml

select:
  - platform: template
    name: Display Temperature Unit
    id: display_temperature_unit
    entity_category: "Config"
    options:
     - "Fahrenheit"
     - "Celsius"
     - "Kelvin"
    initial_option: "Fahrenheit"
    restore_value: true
    optimistic: true
    on_value:
      - globals.set:
          id: temp_unit_changed
          value: "true"

  - platform: template
    name: LED Effect
    id: led_effect_select
    entity_category: "Config"
    options:
      - "None"
      - "Rainbow Effect With Custom Values"
      - "Addressable Rainbow"
      - "Color Wipe"
      - "Scan"
      - "Twinkle"
      - "Fireworks"
      - "Strobe"
      - "Random Twinkle"
      - "AQI Color"
      - "Weather Condition"
      - "Auto Context"
    initial_option: "None"
    restore_value: true
    optimistic: true
    on_value:
      - lambda: |-
          // Don't apply effects during boot - let startup_light_blink handle it
          if (!id(boot_complete)) return;

          std::string effect = id(led_effect_select).state;
          if (effect == "None") {
            auto call = id(rgb_light).turn_off();
            call.perform();
          } else if (effect == "AQI Color") {
            float aqi = id(computed_halo_aqi).state;
            if (std::isnan(aqi) || aqi <= 50) {
              auto call = id(rgb_light).turn_off();
              call.perform();
            } else {
              Color color;
              if (aqi <= 100) color = Color(255, 255, 0); // yellow
              else if (aqi <= 150) color = Color(255, 165, 0); // orange
              else if (aqi <= 200) color = Color(255, 0, 0); // red
              else if (aqi <= 300) color = Color(128, 0, 128); // purple
              else color = Color(128, 0, 0); // maroon
              auto call = id(rgb_light).turn_on();
              call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
              call.perform();
            }
          } else if (effect == "Weather Condition" || effect == "Auto Context") {
            // New lambda effects - activate them
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          } else {
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          }

  - platform: template
    name: Default Page
    id: default_page_select_boot
    entity_category: "config"
    options:
      - "Vertical Clock"
      # AirQ page option (comment out if AirQ packages are disabled)
      - "AirQ"
      # WiFi page option (comment out if WiFi packages are disabled)
      - "WiFi"
      # Weather page options (comment out if weather packages are disabled)
      - "Weather"
      - "Daily Forecast"
      - "Hourly Forecast"
    initial_option: "Vertical Clock"
    restore_value: true
    optimistic: true
    on_value:
      - lambda: |-
          int idx = 0;
          const std::string &choice = id(default_page_select_boot).state;
          // Core pages (always available unless commented out)
          if (choice == "Vertical Clock") idx = 0;
          else if (choice == "AirQ") idx = 1;  // Comment out if AirQ disabled
          else if (choice == "WiFi") idx = 2;
          // Weather page mappings (comment out if weather packages are disabled)
          else if (choice == "Weather") idx = 3;
          else if (choice == "Daily Forecast") idx = 4;
          else if (choice == "Hourly Forecast") idx = 5;
          id(default_page_index) = idx;

interval:
  - interval: 3s  # Reduced from 1s to decrease SPI bus contention
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete);'
          then:
            - script.execute: time_update

  # Note: 1s interval for colon blink is defined in vertical-clock-core.yaml

  - interval: 1s
    then:
      - if:
          condition:
            - binary_sensor.is_off: ink_ha_connected
            - lambda: 'return id(cycleCounter) < 30;'
            - switch.is_on: startup_light_blink

          then:
            - light.turn_on:
                id: rgb_light
                effect: "Addressable Rainbow"
            - lambda: 'id(cycleCounter) += 1;'

  - interval: 1s
    then:
      - if:
          condition:
            - binary_sensor.is_off: ink_ha_connected
            - lambda: 'return id(cycleCounter) > 30;'
            - lambda: 'return id(cycleCounter) < 31;'
            - switch.is_on: startup_light_blink

          then:
            - light.turn_off:
                id: rgb_light
            - lambda: 'id(cycleCounter) += 1;'

  # Batched sensor UI update - prevents LVGL cascade rendering
  - interval: 2s
    then:
      - lambda: |-
          // Only update if sensors changed since last batch
          if (id(sensor_ui_dirty)) {
            const uint32_t now = millis();
            // Ensure minimum 2s between UI refreshes
            if ((now - id(last_sensor_ui_update)) >= 2000) {
              ESP_LOGD("sensor_batch", "Batched sensor UI update triggered");
              id(sensor_ui_dirty) = false;
              id(last_sensor_ui_update) = now;
            }
          }

  # Automatic page rotation - controllable via Home Assistant with custom page selection and order
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
              if (!id(boot_complete)) return false;
              // Only rotate if auto rotation is enabled
              if (!id(auto_page_rotation_enabled)) return false;

              const uint32_t now = millis();
              const uint32_t interval_ms = id(auto_page_rotation_interval) * 1000;

              // Check if enough time has passed since last rotation
              if ((now - id(last_auto_rotation_time)) < interval_ms) return false;

              // Build separate parallel arrays for page info
              std::vector<int> page_orders;
              std::vector<int> page_indices;  // Maps to the page in sorted order

              // Collect enabled pages with their orders (use index to identify page)
              // Index: 0=vertical_clock, 1=AirQ, 2=wifi, 3=weather, 4=hourly_forecast, 5=daily_forecast

              // Core pages
              if (id(page_rotation_vertical_clock_enabled)) {
                page_orders.push_back(id(page_rotation_vertical_clock_order));
                page_indices.push_back(0);
              }
              // AirQ page (conditionally available based on AirQ package)
              // This global is provided by either airq-core.yaml or airq-stubs.yaml
              if (id(page_rotation_AirQ_enabled)) {
                page_orders.push_back(id(page_rotation_AirQ_order));
                page_indices.push_back(1);
              }
              // WiFi page (conditionally available based on WiFi package)
              // This global is provided by either wifi-core.yaml or wifi-stubs.yaml
              if (id(page_rotation_wifi_enabled)) {
                page_orders.push_back(id(page_rotation_wifi_order));
                page_indices.push_back(2);
              }

              // Weather pages (conditionally available based on weather package)
              // These globals are provided by either weather-core.yaml or weather-stubs.yaml
              if (id(page_rotation_weather_enabled)) {
                page_orders.push_back(id(page_rotation_weather_order));
                page_indices.push_back(3);
              }
              if (id(page_rotation_hourly_forecast_enabled)) {
                page_orders.push_back(id(page_rotation_hourly_forecast_order));
                page_indices.push_back(4);
              }
              if (id(page_rotation_daily_forecast_enabled)) {
                page_orders.push_back(id(page_rotation_daily_forecast_order));
                page_indices.push_back(5);
              }

              // If no pages are enabled, don't rotate
              if (page_orders.empty()) {
                ESP_LOGW("page_rotation", "No pages enabled for rotation");
                return false;
              }

              // Sort indices based on their order numbers (bubble sort for simplicity)
              for (size_t i = 0; i < page_orders.size(); i++) {
                for (size_t j = i + 1; j < page_orders.size(); j++) {
                  if (page_orders[j] < page_orders[i]) {
                    std::swap(page_orders[i], page_orders[j]);
                    std::swap(page_indices[i], page_indices[j]);
                  }
                }
              }

              // Use a static variable to track position in rotation sequence
              static int rotation_position = 0;

              // Make sure rotation_position is within bounds
              if (rotation_position >= page_indices.size()) {
                rotation_position = 0;
              }

              // Get the next page to show
              int next_page_id = page_indices[rotation_position];

              // Store the next page ID in current_page_index for the action to use
              id(current_page_index) = next_page_id;

              // Advance rotation position for next time (wrap around)
              rotation_position = (rotation_position + 1) % page_indices.size();

              // Show the next page
              ESP_LOGD("page_rotation", "Rotating to page index %d (order: %d)",
                       next_page_id, page_orders[rotation_position > 0 ? rotation_position - 1 : page_orders.size() - 1]);

              id(last_auto_rotation_time) = now;
              return true;
          then:
            - if:
                condition:
                  lambda: 'return id(current_page_index) == 0;'  # vertical_clock_page
                then:
                  - logger.log: "AUTO PAGE ROTATION -> Vertical Clock Page"
                  - lvgl.page.show:
                      id: vertical_clock_page
                      animation: OUT_LEFT
                      time: 300ms
                else:
                  - if:
                      condition:
                        lambda: 'return id(current_page_index) == 1;'  # AirQ_page
                      then:
                        - logger.log: "AUTO PAGE ROTATION -> AirQ Page"
                        - lvgl.page.show:
                            id: AirQ_page
                            animation: OUT_LEFT
                            time: 300ms
                      else:
                        - if:
                            condition:
                              lambda: 'return id(current_page_index) == 2;'  # wifi_page
                            then:
                              - logger.log: "AUTO PAGE ROTATION -> WiFi Page"
                              - lvgl.page.show:
                                  id: wifi_page
                                  animation: OUT_LEFT
                                  time: 300ms
                            else:
                              - if:
                                  condition:
                                    lambda: 'return id(current_page_index) == 3;'  # weather_forecast_page
                                  then:
                                    - logger.log: "AUTO PAGE ROTATION -> Weather Forecast Page"
                                    - lvgl.page.show:
                                        id: weather_forecast_page
                                        animation: OUT_LEFT
                                        time: 300ms
                                  else:
                                    - if:
                                        condition:
                                          lambda: 'return id(current_page_index) == 4;'  # hourly_forecast_page
                                        then:
                                          - logger.log: "AUTO PAGE ROTATION -> Hourly Forecast Page"
                                          - lvgl.page.show:
                                              id: hourly_forecast_page
                                              animation: OUT_LEFT
                                              time: 300ms
                                        else:
                                          - if:
                                              condition:
                                                lambda: 'return id(current_page_index) == 5;'  # daily_forecast_page
                                              then:
                                                - logger.log: "AUTO PAGE ROTATION -> Daily Forecast Page"
                                                - lvgl.page.show:
                                                    id: daily_forecast_page
                                                    animation: OUT_LEFT
                                                    time: 300ms
                                              else:
                                                - logger.log: "AUTO PAGE ROTATION -> Unknown page index, defaulting to Vertical Clock"
                                                - lvgl.page.show:
                                                    id: vertical_clock_page
                                                    animation: OUT_LEFT
                                                    time: 300ms

api:
  reboot_timeout: 0s  # Disable auto-reboot on API disconnect
  # Increase buffer sizes to handle sensor bursts
  # Default buffer is ~2KB, increase to 8KB
  # This prevents TCP buffer exhaustion during sensor cascades
  on_client_connected:
      - delay: 1s
      - lambda: 'id(cycleCounter) = 30;'
      - lambda: 'id(boot_complete) = true;'
      # Re-apply the saved LED effect selection after HA connects
      - delay: 2s
      - lambda: |-
          std::string effect = id(led_effect_select).state;
          if (effect == "None") {
            auto call = id(rgb_light).turn_off();
            call.perform();
          } else if (effect == "AQI Color") {
            float aqi = id(computed_halo_aqi).state;
            if (std::isnan(aqi) || aqi <= 50) {
              auto call = id(rgb_light).turn_off();
              call.perform();
            } else {
              Color color;
              if (aqi <= 100) color = Color(255, 255, 0);
              else if (aqi <= 150) color = Color(255, 165, 0);
              else if (aqi <= 200) color = Color(255, 0, 0);
              else if (aqi <= 300) color = Color(128, 0, 128);
              else color = Color(128, 0, 0);
              auto call = id(rgb_light).turn_on();
              call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
              call.perform();
            }
          } else if (effect == "Weather Condition" || effect == "Auto Context") {
            // New lambda effects - activate them
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          } else {
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          }
      - delay: 500ms
      # Note: BLE tracker start/stop on API connection is defined in ble-core.yaml

  services:
    # Note: calibrate_co2_value and sen55_clean services are defined in airq-core.yaml
    - service: set_display_page
      variables:
        page_name: string
      then:
        # IMPORTANT: If you disable a module, comment out its page handling below
        # Otherwise you'll get compilation errors about missing page IDs

        # AirQ page handling (comment out if airq-stubs.yaml is used)
        - if:
            condition:
              lambda: 'return page_name == "AirQ" || page_name == "AirQ";'
            then:
              - lvgl.page.show: AirQ_page
            else:
              # WiFi page handling (comment out if wifi-stubs.yaml is used)
              - if:
                  condition:
                    lambda: 'return page_name == "wifi" || page_name == "WiFi";'
                  then:
                    - lvgl.page.show: wifi_page
                  else:
                    # Weather page handling (comment out if weather-stubs.yaml is used)
                    - if:
                        condition:
                          lambda: 'return page_name == "weather" || page_name == "Weather";'
                        then:
                          - lvgl.page.show: weather_forecast_page
                        else:
                          - if:
                              condition:
                                lambda: 'return page_name == "daily" || page_name == "Daily";'
                              then:
                                - lvgl.page.show: daily_forecast_page
                              else:
                                - logger.log:
                                    format: "Unknown page requested: %s"
                                    args: ['page_name.c_str()']
                                    level: WARN

i2c:
  - sda: 9
    scl: 48
    id: lily_i2c
  - sda: 15
    scl: 10
    id: touch_i2c

output:
  - platform: ledc
    pin: 1
    id: backlight
    frequency: 100Hz  #Datasheet suggests low-frequency PWM. Should prevent stability issues.
    
# sy6970:
#   i2c_id: touch_i2c
#   state_led_enable: false  # To turn off the blinking green status LED

display:
  - platform: qspi_dbi
    id: lily_display
    model: AXS15231
    data_rate: 5MHz
    spi_id: lily_spi
    dimensions:
      height: 640
      width: 180
    cs_pin: 12
    reset_pin: 16
    rotation: 0
    auto_clear_enabled: false

# Touchscreen re-enabled with protective measures:
# - 100ms internal rate limiter in axs15231_touchscreen.cpp
# - Interrupt-only mode (no continuous polling)
# - 5s debounce to filter phantom touches
# - Coordinate validation to reject invalid touches
touchscreen:
  - platform: axs15231
    id: lily_touch
    display: lily_display
    i2c_id: touch_i2c
    interrupt_pin: GPIO11
    update_interval: never  # Interrupt-only mode - rely solely on hardware interrupts, no polling
    transform:
      mirror_x: false
      mirror_y: false
      swap_xy: false
    on_touch:
      - lambda: |-
          // Validate touch coordinates - filter out spurious/phantom touches
          if (touch.x < 0 || touch.x > 180 || touch.y < 0 || touch.y > 640) {
            ESP_LOGW("touch", "Invalid touch coordinates: x=%d, y=%d - ignoring", touch.x, touch.y);
            return;
          }
          ESP_LOGI("touch", "Touch at x=%d, y=%d", touch.x, touch.y);

          // Reset auto-rotation timer on any valid touch to prevent interruption during manual navigation
          id(last_auto_rotation_time) = millis();
          ESP_LOGD("touch", "Auto-rotation timer reset");

web_server:
  port: 80

image:
  - file: https://yashmulgaonkar.github.io/assets/YM.png
    id: ym_logo
    resize: 25x25
    type: RGB565
    transparency: alpha_channel

color:
  - id: my_red
    red: 100%
    green: 0%
    blue: 0%
  - id: my_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: my_green
    red: 0%
    green: 100%
    blue: 0%
  - id: my_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: my_gray
    red: 50%
    green: 50%
    blue: 50%
  - id: my_orange
    red: 100%
    green: 50%
    blue: 0%
  - id: my_teal
    red: 0%
    green: 100%
    blue: 100%
  - id: my_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_black
    red: 0%
    green: 0%
    blue: 0%

time:
  - platform: homeassistant
    id: ha_time
    on_time_sync:
      - script.execute: time_update
  - platform: sntp
    id: sntp_time
    timezone: America/New_York
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
      - 2.pool.ntp.org
    on_time_sync:
      - script.execute: time_update

script:
  - id: page_transition_cleanup
    mode: queued  # Queue executions instead of warning about duplicates
    max_runs: 2   # Allow up to 2 queued runs
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete) && !id(ota_in_progress);'
          then:
            - delay: 50ms  # Small delay to prevent rapid successive calls
            - lambda: |-
                // Safety check: Only run if LVGL is fully initialized
                lv_obj_t *scr = lv_scr_act();
                if (scr == NULL) {
                  return;  // Silently skip if not initialized
                }

                // Log current memory state before cleanup
                ESP_LOGD("lvgl", "Page transition cleanup - Free heap: %d", esp_get_free_heap_size());

                // Clear all cached strings to free memory
                id(time_update_last_text).clear();
                id(weather_last_condition).clear();

                // Force LVGL to invalidate current screen and redraw
                lv_obj_invalidate(scr);

                // Force immediate display flush to prevent buffer buildup
                lv_refr_now(NULL);

number:
  - platform: template
    name: "Auto Page Rotation Interval"
    id: page_rotation_interval
    icon: mdi:timer
    restore_value: true
    initial_value: 30
    min_value: 5
    max_value: 300
    entity_category: "config"
    unit_of_measurement: "s"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(auto_page_rotation_interval) = (int)x;'
      - logger.log:
          format: "Page rotation interval changed to %d seconds"
          args: ['(int)x']

  # Page rotation order numbers (1-6, lower numbers show first)
  # Note: "Page Order: Vertical Clock Page" number is defined in vertical-clock-core.yaml
  # Note: "Page Order: AirQ Page" number is defined in airq-core.yaml
  # Note: "Page Order: WiFi Page" number is defined in wifi-core.yaml
  # Note: SEN55 Temperature/Humidity Offset numbers are defined in airq-core.yaml

binary_sensor:
  - platform: status
    name: Online
    id: ink_ha_connected

  - platform: template
    name: "Display Backlight Active"
    id: display_backlight_state
    entity_category: "diagnostic"
    lambda: 'return id(display_backlight_is_on);'

sensor:
  # Display refresh rate monitor
  - platform: template
    name: "Display Refresh Count"
    id: display_refresh_counter
    internal: true
    update_interval: never
    entity_category: "diagnostic"

  - platform: uptime
    name: Uptime
    id: sys_uptime
    update_interval: 60s

  # Note: wifi_signal (RSSI) sensor is defined in wifi-core.yaml

  - platform: template
    name: "Time Update Duration"
    id: time_update_duration_sensor
    internal: true  # Don't send to Home Assistant - internal diagnostic only
    unit_of_measurement: "ms"
    accuracy_decimals: 0
    icon: "mdi:timer-outline"
    entity_category: "diagnostic"
    update_interval: never

  # Weather Icon Update Duration sensor moved to packages/weather-core.yaml
  # AirQ sensors (computed_aqi, scd4x, mics_4514, bme280, sen5x) moved to packages/airq-core.yaml
  # Weather sensors removed - now in packages/weather-sensors.yaml

# Weather icon fonts (icons_20, icons_40, icons_50, icons_80, icons_100)
# have been moved to packages/weather-pages.yaml
# Vertical clock fonts (montserrat_80, montserrat_50, montserrat_24)
# have been moved to packages/vertical-clock-core.yaml

light:
  # - platform: esp32_rmt_led_strip
  #   id: rgb_light
  #   name: "Halo"
  #   pin: GPIO47
  #   rgb_order: GRB
  #   default_transition_length: 2s
  #   chipset: SK6812
  #   num_leds: 11
  #   effects:
  #     - pulse:
  #         name: "Slow Pulse" 
  #         transition_length: 500ms
  #         update_interval: 500ms
  #         min_brightness: 10%
  #         max_brightness: 50%
  #     - addressable_rainbow:
  #         name: Rainbow Effect With Custom Values
  #         speed: 10
  #         width: 50

  - platform: esp32_rmt_led_strip
    name: Halo
    id: rgb_light
    rgb_order: GRB
    pin: GPIO47
    num_leds: 12
    chipset: WS2812
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_rainbow:
          name: Rainbow Effect With Custom Values
          speed: 10
          width: 50
      - addressable_rainbow:
          name: Addressable Rainbow
      - addressable_color_wipe:
          name: Color Wipe
      - addressable_scan:
          name: Scan
      - addressable_twinkle:
          name: Twinkle
      - addressable_fireworks:
          name: Fireworks
      - strobe:
          name: Strobe
      - addressable_random_twinkle:
          name: Random Twinkle
      - addressable_lambda:
          name: "Weather Condition"
          update_interval: 250ms
          lambda: |-
            // Get the current weather condition from Day 1 forecast
            static uint32_t last_flash = 0;
            static bool flash_on = false;
            static uint32_t next_flash_delay = 1500;
            uint32_t now = millis();

            std::string condition = id(forecast_day1_condition).state;
            std::string normalized = condition;
            std::transform(normalized.begin(), normalized.end(), normalized.begin(), ::tolower);

            // Check if it's a lightning condition
            bool is_lightning = (normalized.find("lightning-rainy") != std::string::npos ||
                                normalized.find("lightning") != std::string::npos);

            Color weather_color;

            if (is_lightning) {
              // Lightning effect - random flashes
              // Flash randomly every 1-3 seconds
              if (now - last_flash > next_flash_delay) {
                flash_on = !flash_on;
                last_flash = now;
                // Generate random delay between 1000-3000ms for next flash
                next_flash_delay = 1000 + (esp_random() % 2000);
              }

              if (flash_on) {
                weather_color = Color(255, 255, 255);  // Bright white flash
              } else {
                weather_color = Color(255, 20, 147);   // Deep pink between flashes
              }
            } else {
              // Regular solid weather colors
              if (normalized.find("clear-night") != std::string::npos) {
                weather_color = Color(106, 90, 205);  // Slate Blue
              } else if (normalized.find("sunny") != std::string::npos || normalized.find("clear") != std::string::npos) {
                weather_color = Color(255, 215, 0);   // Gold
              } else if (normalized.find("snowy-rainy") != std::string::npos) {
                weather_color = Color(175, 238, 238); // Light Cyan
              } else if (normalized.find("partlycloudy") != std::string::npos) {
                weather_color = Color(135, 206, 250); // Light Sky Blue
              } else if (normalized.find("cloudy") != std::string::npos) {
                weather_color = Color(169, 169, 169); // Dark Gray
              } else if (normalized.find("rainy") != std::string::npos) {
                weather_color = Color(65, 105, 225);  // Royal Blue
              } else if (normalized.find("snowy") != std::string::npos) {
                weather_color = Color(220, 220, 220); // Gainsboro
              } else if (normalized.find("fog") != std::string::npos) {
                weather_color = Color(176, 196, 222); // Light Steel Blue
              } else if (normalized.find("windy") != std::string::npos) {
                weather_color = Color(144, 238, 144); // Light Green
              } else {
                weather_color = Color(255, 255, 255); // White (default)
              }
            }

            // Set all LEDs to the weather condition color
            it.all() = weather_color;
      - addressable_lambda:
          name: "Auto Context"
          update_interval: 250ms
          lambda: |-
            static uint32_t last_flash = 0;
            static bool flash_on = false;
            static uint32_t next_flash_delay = 1500;
            uint32_t now = millis();

            Color led_color;
            int page = id(current_page_index);

            // AirQ page (1) - show AQI color
            if (page == 1) {
              float aqi = id(computed_halo_aqi).state;
              if (std::isnan(aqi) || aqi <= 50) {
                // Turn off LEDs when air quality is good (just like AQI Color mode)
                led_color = Color(0, 0, 0);        // Off (Good)
              } else if (aqi <= 100) {
                led_color = Color(255, 255, 0);    // Yellow (Moderate)
              } else if (aqi <= 150) {
                led_color = Color(255, 165, 0);    // Orange (Unhealthy for Sensitive)
              } else if (aqi <= 200) {
                led_color = Color(255, 0, 0);      // Red (Unhealthy)
              } else if (aqi <= 300) {
                led_color = Color(128, 0, 128);    // Purple (Very Unhealthy)
              } else {
                led_color = Color(128, 0, 0);      // Maroon (Hazardous)
              }
            }
            // Weather pages (3) - show weather condition color
            else if (page == 3) {
              std::string condition = id(forecast_day1_condition).state;
              std::string normalized = condition;
              std::transform(normalized.begin(), normalized.end(), normalized.begin(), ::tolower);

              // Check if it's a lightning condition
              bool is_lightning = (normalized.find("lightning-rainy") != std::string::npos ||
                                  normalized.find("lightning") != std::string::npos);

              if (is_lightning) {
                // Lightning effect - random flashes
                if (now - last_flash > next_flash_delay) {
                  flash_on = !flash_on;
                  last_flash = now;
                  next_flash_delay = 1000 + (esp_random() % 2000);  // Random 1000-3000ms
                }
                led_color = flash_on ? Color(255, 255, 255) : Color(255, 20, 147);
              } else if (normalized.find("clear-night") != std::string::npos) {
                led_color = Color(106, 90, 205);   // Slate Blue
              } else if (normalized.find("sunny") != std::string::npos || normalized.find("clear") != std::string::npos) {
                led_color = Color(255, 215, 0);    // Gold
              } else if (normalized.find("snowy-rainy") != std::string::npos) {
                led_color = Color(175, 238, 238);  // Light Cyan
              } else if (normalized.find("partlycloudy") != std::string::npos) {
                led_color = Color(135, 206, 250);  // Light Sky Blue
              } else if (normalized.find("cloudy") != std::string::npos) {
                led_color = Color(169, 169, 169);  // Dark Gray
              } else if (normalized.find("rainy") != std::string::npos) {
                led_color = Color(65, 105, 225);   // Royal Blue
              } else if (normalized.find("snowy") != std::string::npos) {
                led_color = Color(220, 220, 220);  // Gainsboro
              } else if (normalized.find("fog") != std::string::npos) {
                led_color = Color(176, 196, 222);  // Light Steel Blue
              } else if (normalized.find("windy") != std::string::npos) {
                led_color = Color(144, 238, 144);  // Light Green
              } else {
                led_color = Color(255, 255, 255);  // White (default)
              }
            }
            // Network page (1) or other - turn LEDs fully off instead of dim white
            else {
              led_color = Color(0, 0, 0);    // Off
            }

            // Set all LEDs to the contextual color
            it.all() = led_color;

  - platform: monochromatic
    output: backlight
    name: "Display Backlight"
    id: display_backlight
    restore_mode: ALWAYS_ON
    on_turn_on:
      - logger.log: "Display backlight turned ON"
      - lambda: 'id(display_backlight_is_on) = true;'
      - binary_sensor.template.publish:
          id: display_backlight_state
          state: ON
    on_turn_off:
      - logger.log: "Display backlight turned OFF"
      - lambda: 'id(display_backlight_is_on) = false;'
      - binary_sensor.template.publish:
          id: display_backlight_state
          state: OFF

lvgl:
  id: lvgl_main
  displays:
    - lily_display
  touchscreens:
    - lily_touch
  buffer_size: 25%  # Increased from 20% to 25% for better performance
                    # IMPORTANT: If enabling BLE, reduce to 15-20% to prevent heap exhaustion
  disp_bg_color: 0x000000
  disp_bg_opa: COVER
  disp_bg_image: none
  log_level: WARN  # Reduce logging overhead

  pages:
    # Vertical Clock page (core page)
    - !include packages/vertical-clock-display.yaml
    # AirQ page (optional - comment out to disable AirQ monitoring)
    # Note: AirQ is ENABLED by default - See packages/README-AIRQ-INTEGRATION.md
    - !include packages/airq-display.yaml
    # WiFi page - choose one of the following:
    # For WiFi + WireGuard: !include packages/lvgl-wifi-wireguard-page.yaml
    # For WiFi only: !include packages/lvgl-wifi-page.yaml
    - !include packages/lvgl-wifi-wireguard-page.yaml
    # Weather pages (optional - comment out all 8 lines below to disable weather)
    # Note: Weather text sensors and fonts are in weather-fonts-text.yaml package
    - !include packages/weather-page-forecast.yaml       # Page 3: Current weather
    - !include packages/weather-page-hourly.yaml         # Page 4: Hourly forecast
    - !include packages/weather-page-hourly-2.yaml       # Page 4 alternate: Hourly forecast
    - !include packages/weather-page-daily.yaml          # Page 5: Daily forecast overview
    - !include packages/weather-page-days-4-5.yaml       # Days 4-5 detailed
    - !include packages/weather-page-days-6-7.yaml       # Days 6-7 detailed
    - !include packages/weather-page-days-8-9.yaml       # Days 8-9 detailed
    - !include packages/weather-page-day-10.yaml         # Day 10 detailed

esphome:
  name: ${name}
  on_boot:
    - priority: 800  # Very early - before components load
      then:
        - delay: 50ms  # Brief delay for LVGL to initialize
        - lvgl.page.show: vertical_clock_page
        - logger.log: "Set initial page to Vertical Clock"
    - priority: -100
      then:
        - logger.log: "Boot sequence starting (priority -100)"
        - light.turn_off: rgb_light
        - delay: 1s  # Brief delay for LVGL to initialize
        - lambda: |-
            const std::string &choice = id(default_page_select_boot).state;
            // Core pages
            if (choice == "Vertical Clock") {
              id(default_page_index) = 0;  // vertical_clock_page
            } else if (choice == "AirQ") {  // Comment out if AirQ disabled
              id(default_page_index) = 1;  // AirQ_page
            } else if (choice == "WiFi") {
              id(default_page_index) = 2;  // wifi_page
            // Weather page mappings (comment out if weather packages are disabled)
            } else if (choice == "Weather") {
              id(default_page_index) = 3;  // weather_forecast_page
            } else if (choice == "Daily Forecast") {
              id(default_page_index) = 4;  // daily_forecast_page
            } else if (choice == "Hourly Forecast") {
              id(default_page_index) = 5;  // hourly_forecast_page
            } else {
              id(default_page_index) = 0;  // Default to vertical clock if unknown
            }
        - logger.log:
            format: "Setting default page (index: %d)"
            args: ['id(default_page_index)']
        - if:
            condition:
              lambda: 'return id(default_page_index) == 0;'  # vertical_clock_page
            then:
              - logger.log: "Showing Vertical Clock page"
              - lvgl.page.show: vertical_clock_page
            else:
              - if:
                  condition:
                    lambda: 'return id(default_page_index) == 1;'  # AirQ_page (comment out if AirQ disabled)
                  then:
                    - logger.log: "Showing AirQ page"
                    - lvgl.page.show: AirQ_page
                  else:
                    - if:
                        condition:
                          lambda: 'return id(default_page_index) == 2;'  # wifi_page
                        then:
                          - logger.log: "Showing WiFi page"
                          - lvgl.page.show: wifi_page
                        else:
                        # Weather page boot logic (comment out if weather packages are disabled)
                        - if:
                            condition:
                              lambda: 'return id(default_page_index) == 3;'  # weather_forecast_page
                            then:
                              - logger.log: "Showing Weather page"
                              - lvgl.page.show: weather_forecast_page
                            else:
                              - if:
                                  condition:
                                    lambda: 'return id(default_page_index) == 4 || id(default_page_index) == 5;'  # hourly/daily forecast
                                  then:
                                    - logger.log: "Showing Daily Forecast page"
                                    - lvgl.page.show: daily_forecast_page
                                  else:
                                    - logger.log: "Unknown page index, defaulting to Vertical Clock"
                                    - lvgl.page.show: vertical_clock_page
        - logger.log: "Boot sequence complete"# Test comment

#Define Project
substitutions:
  name: halo
  version: "25.11.01.0746"
  device_description: ${name} - v${version}.

# ============================================================================
# Core Packages - Minimal Required Configuration
# ============================================================================
# This file now contains ONLY the absolute essentials needed for all devices.
# All optional features have been moved to device-specific configuration files.
#
# Device files should include (in this order):
#   1. Optional feature packages (airq, weather, wifi, ble, wireguard, memory_stats)
#   2. LVGL pages package matching enabled features
#   3. This core package (import last to allow device overrides)
#
# See packages/README-DEVICE-CONFIGURATION.md for complete examples
# See halo-v1-79e384.yaml for a template
# ============================================================================

# packages:
  # ============================================================================
  # ESSENTIAL PACKAGES - Always Required
  # ============================================================================
  # These are the bare minimum needed for any Halo device to function

  # Page registry - manages page rotation system
  # page_registry: !include packages/page-registry.yaml

globals:
  # Current page tracking using string name
  - id: current_page_name
    type: std::string
    restore_value: no
    initial_value: '"vertical_clock"'

  # Vertical clock - core display feature
  # vertical_clock: !include packages/vertical-clock-core.yaml

  # Page rotation settings - which pages are included
  - id: page_rotation_vertical_clock_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'

  # Page rotation order (1-6, 0 means disabled)
  - id: page_rotation_vertical_clock_order
    type: int
    restore_value: yes
    initial_value: '6'

  # Colon blink state for clock display
  - id: colon_blink_state
    type: bool
    restore_value: no
    initial_value: 'true'

  - id: cycleCounter
    type: int
    restore_value: no
    initial_value: '0'
  - id: temp_unit_changed
    type: bool
    initial_value: "true"
  - id: last_touch_time
    type: int
    initial_value: '0'
  - id: auto_page_rotation_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: auto_page_rotation_interval
    type: int
    restore_value: yes
    initial_value: '30'  # Default 30 seconds
  - id: last_auto_rotation_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  # Page rotation settings - which pages are included
  # Note: page_rotation_AirQ_enabled is defined in airq-core.yaml or airq-stubs.yaml
  # Note: page_rotation_wifi_enabled is defined in wifi-core.yaml or wifi-stubs.yaml
  # Note: page_rotation_vertical_clock_enabled is defined in vertical-clock-core.yaml
  # Page rotation order (1-5, 0 means disabled)
  # Note: page_rotation_AirQ_order is defined in airq-core.yaml or airq-stubs.yaml
  # Note: page_rotation_wifi_order is defined in wifi-core.yaml or wifi-stubs.yaml
  # Note: page_rotation_vertical_clock_order is defined in vertical-clock-core.yaml
  - id: default_page_index
    type: int
    restore_value: yes
    initial_value: '0'
  - id: current_page_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: ota_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'  # Set to true during OTA or other critical operations
  - id: time_update_last_started
    type: int
    restore_value: no
    initial_value: '0'
  - id: time_update_last_duration
    type: int
    restore_value: no
    initial_value: '0'
  - id: time_update_last_text
    type: std::string
    restore_value: no
    initial_value: ""
  - id: time_update_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'
  # Note: colon_blink_state is defined in vertical-clock-core.yaml
  - id: display_backlight_is_on
    type: bool
    restore_value: no
    initial_value: 'true'
  # Sensor UI update batching
  - id: sensor_ui_dirty
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_sensor_ui_update
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: page_rotation_AirQ_enabled
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: page_rotation_AirQ_order
    type: int
    restore_value: no
    initial_value: '99'
  
  - id: page_rotation_wifi_enabled
    type: bool
    restore_value: no
    initial_value: 'false'

  - id: page_rotation_wifi_order
    type: int
    restore_value: no
    initial_value: '99'
  
  - id: page_rotation_weather_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: page_rotation_daily_forecast_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: page_rotation_hourly_forecast_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'

  # Page rotation order for weather pages
  - id: page_rotation_weather_order
    type: int
    restore_value: yes
    initial_value: '3'
  - id: page_rotation_daily_forecast_order
    type: int
    restore_value: yes
    initial_value: '4'
  - id: page_rotation_hourly_forecast_order
    type: int
    restore_value: yes
    initial_value: '5'

  # Weather display state tracking
  - id: weather_last_started
    type: int
    restore_value: no
    initial_value: '0'
  - id: weather_last_duration
    type: int
    restore_value: no
    initial_value: '0'
  - id: weather_last_condition
    type: std::string
    restore_value: no
    initial_value: ""
  - id: weather_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'

  # Current weather
  - id: weather_current_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_apparent_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_condition
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: weather_current_humidity
    type: float
    restore_value: no
    initial_value: 'NAN'

  # Forecast arrays (10 days)
  - id: weather_forecast_temp_high
    type: float[10]
    restore_value: no

  - id: weather_forecast_temp_low
    type: float[10]
    restore_value: no

  - id: weather_forecast_condition
    type: std::string[10]
    restore_value: no

  - id: weather_forecast_precip_prob
    type: float[10]
    restore_value: no

  # Hourly forecast arrays (24 hours)
  - id: weather_hourly_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_apparent_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_condition
    type: std::string[24]
    restore_value: no

  - id: weather_hourly_precip_prob
    type: float[24]
    restore_value: no

  # Tracking
  - id: weather_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: weather_on_weather_page
    type: bool
    restore_value: no
    initial_value: 'false'

font:
  # Large fonts for vertical clock
  - file: "gfonts://Montserrat"
    id: montserrat_80
    size: 80
    bpp: 4
    glyphs: " 0123456789:-"

  - file: "gfonts://Montserrat"
    id: montserrat_50
    size: 50
    bpp: 4
    glyphs: " 0123456789APM-"

  - file: "gfonts://Montserrat"
    id: montserrat_24
    size: 24
    bpp: 4
    glyphs: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ,:-"

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icons_100
    size: 100
    bpp: 4
    glyphs: [
      "\U000F0594", # clear-night
      "\U000F0590", # cloudy
      "\U000F0F2F", # exceptional
      "\U000F0591", # fog
      "\U000F0592", # hail
      "\U000F0593", # lightning
      "\U000F067E", # lightning-rainy
      "\U000F0595", # partlycloudy
      "\U000F0596", # pouring
      "\U000F0597", # rainy
      "\U000F0598", # snowy
      "\U000F067F", # snowy-rainy
      "\U000F0599", # sunny
      "\U000F059D", # windy
      "\U000F059E", # windy-variant
      "\U000F14E4", # sunny-off
      ]

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icons_80
    size: 80
    bpp: 4
    glyphs: [
      "\U000F0594", # clear-night
      "\U000F0590", # cloudy
      "\U000F0F2F", # exceptional
      "\U000F0591", # fog
      "\U000F0592", # hail
      "\U000F0593", # lightning
      "\U000F067E", # lightning-rainy
      "\U000F0595", # partlycloudy
      "\U000F0596", # pouring
      "\U000F0597", # rainy
      "\U000F0598", # snowy
      "\U000F067F", # snowy-rainy
      "\U000F0599", # sunny
      "\U000F059D", # windy
      "\U000F059E", # windy-variant
      "\U000F14E4", # sunny-off
      ]

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icons_50
    size: 50
    bpp: 4
    glyphs: [
      "\U000F0594", # clear-night
      "\U000F0590", # cloudy
      "\U000F0F2F", # exceptional
      "\U000F0591", # fog
      "\U000F0592", # hail
      "\U000F0593", # lightning
      "\U000F067E", # lightning-rainy
      "\U000F0595", # partlycloudy
      "\U000F0596", # pouring
      "\U000F0597", # rainy
      "\U000F0598", # snowy
      "\U000F067F", # snowy-rainy
      "\U000F0599", # sunny
      "\U000F059D", # windy
      "\U000F059E", # windy-variant
      "\U000F14E4", # sunny-off
      ]

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icons_40
    size: 40
    bpp: 4
    glyphs: [
      "\U000F0594", # clear-night
      "\U000F0590", # cloudy
      "\U000F0F2F", # exceptional
      "\U000F0591", # fog
      "\U000F0592", # hail
      "\U000F0593", # lightning
      "\U000F067E", # lightning-rainy
      "\U000F0595", # partlycloudy
      "\U000F0596", # pouring
      "\U000F0597", # rainy
      "\U000F0598", # snowy
      "\U000F067F", # snowy-rainy
      "\U000F0599", # sunny
      "\U000F059D", # windy
      "\U000F059E", # windy-variant
      "\U000F14E4", # sunny-off
      ]

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icons_20
    size: 20
    bpp: 4
    glyphs: [
      "\U000F0594", # clear-night
      "\U000F0590", # cloudy
      "\U000F0F2F", # exceptional
      "\U000F0591", # fog
      "\U000F0592", # hail
      "\U000F0593", # lightning
      "\U000F067E", # lightning-rainy
      "\U000F0595", # partlycloudy
      "\U000F0596", # pouring
      "\U000F0597", # rainy
      "\U000F0598", # snowy
      "\U000F067F", # snowy-rainy
      "\U000F0599", # sunny
      "\U000F059D", # windy
      "\U000F059E", # windy-variant
      "\U000F14E4", # sunny-off
      ]

  # Time update script - NOW INCLUDED IN DEVICE FILES
  # Device files should include the appropriate version:
  #   - time-update-clock-only.yaml (if AirQ disabled)
  #   - time-update-basic.yaml (if AirQ enabled, no WireGuard)
  #   - time-update-wireguard.yaml (if WireGuard enabled)
  # time_update: !include packages/time-update-basic.yaml  # REMOVED - include in device file

  # ============================================================================
  # OPTIONAL PACKAGES - NOW CONTROLLED BY DEVICE FILES
  # ============================================================================
  # The following packages have been REMOVED from Core.
  # Include them in your device-specific configuration as needed:
  #
  # Memory Statistics (recommended for debugging):
  #   - memory-stats.yaml
  #
  # WireGuard VPN:
  #   - wireguard.yaml + wireguard-display.yaml + time-update-wireguard.yaml
  #
  # WiFi Display (connection info):
  #   - wifi-display.yaml
  #
  # AirQ Monitoring:
  #   - airq-core.yaml + airq-display.yaml (to enable)
  #   - airq-stubs.yaml (to disable)
  #
  # Weather Forecasting:
  #   - weather-core.yaml + weather-sensors.yaml + weather-fonts-text.yaml (to enable)
  #   - weather-stubs.yaml (to disable)
  #
  # WiFi Monitoring Page:
  #   - wifi-core.yaml (to enable)
  #   - wifi-stubs.yaml (to disable)
  #
  # BLE (Bluetooth):
  #   - ble-core.yaml (to enable - now supported with PSRAM configuration)
  #   - ble-stubs.yaml (to disable if not needed)

psram:
  mode: octal
  speed: 80MHz  # Optimal speed for stability with BLE

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  cpu_frequency: 240MHz

  framework:
    type: esp-idf
    advanced:
      enable_idf_experimental_features: true
      # ========================================================================
      # PSRAM Configuration for BLE and Memory-Intensive Operations
      # ========================================================================
      # These settings configure ESP-IDF to use PSRAM for dynamic allocations
      # instead of the limited internal heap, which prevents OOM crashes
      # ========================================================================
    # platform_version: 6.9.0
    # version: 5.3.1
    sdkconfig_options:
      # Enable PSRAM support
      CONFIG_SPIRAM_USE: "y"
      CONFIG_SPIRAM_MODE_OCT: "y"
      CONFIG_SPIRAM_SPEED_80M: "y"                 # Max stable PSRAM speed on S3

      # Memory allocation strategy - Use PSRAM for large allocations
      # This moves malloc() calls to PSRAM when size > threshold
      CONFIG_SPIRAM_USE_MALLOC: "y"
      # CONFIG_SPIRAM_MALLOC_ALWAYSINTERNAL: "16384"  # Keep allocations < 16KB in internal RAM
      CONFIG_SPIRAM_MALLOC_ALWAYSINTERNAL: "4096"   # AGGRESSIVE: Force most allocations to PSRAM
                                                     # Sensors ~500-1200 bytes each = go to PSRAM
                                                     # Only tiny allocations (<4KB) stay internal
      # BLE-specific PSRAM configuration
      # Move BLE controller memory to PSRAM to free internal heap
      CONFIG_BT_NIMBLE_MEM_ALLOC_MODE_EXTERNAL: "y"  # Use PSRAM for NimBLE stack
      CONFIG_BT_NIMBLE_USE_ESP_TIMER: "y"  # Use ESP timer for better performance
      CONFIG_BT_NIMBLE_MAX_CONNECTIONS: "4"         # Reduce if not using multiple devices
      CONFIG_BT_NIMBLE_HOST_TASK_STACK_SIZE: "8192" # Move BLE stack to PSRAM 

      # LWIP (networking) PSRAM usage
      
      # CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: "32"  # Increase network buffers
      CONFIG_LWIP_TCPIP_RECVMBOX_SIZE: "64"         # Bigger RX mailbox queue
      # CONFIG_LWIP_TCP_RECVMBOX_SIZE: "12"
      # CONFIG_LWIP_UDP_RECVMBOX_SIZE: "12"
      CONFIG_LWIP_TCP_RECVMBOX_SIZE: "24"
      CONFIG_LWIP_UDP_RECVMBOX_SIZE: "24"
      
      # Task stack allocation in PSRAM
      # Move large task stacks to PSRAM to free internal RAM
      CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY: "y"

      # LVGL configuration for PSRAM
      # Allow LVGL buffers to use PSRAM
      CONFIG_LV_MEM_CUSTOM: "y"
      CONFIG_LV_MEM_CUSTOM_ALLOC_EXTERNAL: "y"      # Force LVGL to use PSRAM
      CONFIG_LV_MEM_SIZE: "262144"                  # 256KB LVGL heap for large buffers


      # WiFi/BT coexistence optimization
      CONFIG_SPIRAM_TRY_ALLOCATE_WIFI_LWIP: "y"    # Allow WiFi/LWIP allocations in PSRAM
      
      # CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: "8"  # Reduce WiFi RX buffers
      # CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: "16"
      # CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM: "16"
      CONFIG_ESP_WIFI_STATIC_RX_BUFFER_NUM: "16"     # Fewer always-on buffers
      CONFIG_ESP_WIFI_DYNAMIC_RX_BUFFER_NUM: "32"   # More on-demand buffers
      CONFIG_ESP_WIFI_DYNAMIC_TX_BUFFER_NUM: "32"
      CONFIG_ESP_WIFI_RX_BA_WIN: "32"
      CONFIG_ESP_WIFI_TX_BA_WIN: "32"
      CONFIG_ESP_WIFI_RX_MGMT_BUF_NUM: "32"


      # Increase task watchdog timeout for BLE operations
      # CONFIG_ESP_TASK_WDT_TIMEOUT_S: "10"
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "12"           # Extend watchdog for long BLE ops

      # ========================================================================
      # HOME ASSISTANT API & SENSOR OPTIMIZATION
      # ========================================================================
      # With 125+ weather sensors, API buffers and sensor objects need PSRAM
      # ========================================================================

      # Increase API service call stack (many sensors = heavy API traffic)
      # CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: "3072"  # Default 1536, increase for sensor load
      CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: "4096"   # Was 3072
      # Move protocol buffers (API communication) to PSRAM
      # This helps with the large volume of HA sensor updates
      # CONFIG_SPIRAM_MALLOC_RESERVE_INTERNAL: "32768"  # Reserve 32KB internal for critical ops
      CONFIG_SPIRAM_MALLOC_RESERVE_INTERNAL: "16384"  # Reduce reserved internal heap (was 32KB)
      # Increase default task stack size for sensor processing
      # CONFIG_ESP_MAIN_TASK_STACK_SIZE: "8192"  # Default 3584, increase for many sensors
      CONFIG_ESP_MAIN_TASK_STACK_SIZE: "12288"      # Was 8192, increase for sensor-heavy loads
      CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: "2"
      CONFIG_FREERTOS_USE_STATIC_TASK_CLEAN_UP: "y"
      # LWIP (networking) optimization for API traffic
      # CONFIG_LWIP_MAX_SOCKETS: "16"  # Support more simultaneous connections
      CONFIG_LWIP_MAX_SOCKETS: "24"                 # Support more open sockets
      CONFIG_LWIP_SO_RCVBUF: "y"  # Enable socket receive buffer
      CONFIG_LWIP_SO_RCVBUF_DEFAULT: "8192"         # Per-socket receive buffer
      CONFIG_TCP_MAXRTX: "16"
      CONFIG_TCP_SYNMAXRTX: "8"

      # Memory debugging (optional - enable if still having issues)
      CONFIG_HEAP_TRACING_STANDALONE: "y"
      CONFIG_HEAP_TRACING: "y"
      CONFIG_HEAP_TASK_TRACKING: "y"                # Track which task allocates what
      CONFIG_HEAP_POISONING_LIGHT: "y"              # Detect memory corruption (minimal overhead)
      CONFIG_ESP_SYSTEM_MEMPROT_FEATURE: "n"        # Disable memory protection if it causes issues

external_components:
  - source: github://truffshuff/esphome-components
    components: [axs15231, sy6970]

  # - source: github://pr#7770 # RMT driver, remove rmt_channel when using esp-idf
  #   components: [ remote_base, remote_receiver, remote_transmitter, esp32_rmt, esp32_rmt_led_strip ]
  #   refresh: 0s

spi:
  id: lily_spi
  type: quad
  clk_pin: 17
  data_pins:
    - 13
    - 18
    - 21
    - 14

captive_portal:

logger:
  level: DEBUG

switch:
  - platform: template
    name: "Auto Page Rotation"
    id: auto_page_rotation
    icon: mdi:rotate-3d-variant
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(auto_page_rotation_enabled) = true;'
      - logger.log: "Auto page rotation enabled"
    on_turn_off:
      - lambda: 'id(auto_page_rotation_enabled) = false;'
      - logger.log: "Auto page rotation disabled"
  - platform: template
    name: "Startup Light Blink"
    id: startup_light_blink
    icon: mdi:lightbulb
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"

  # Page rotation selection switches
  # Note: "24h Clock Format" switch is defined in vertical-clock-core.yaml
  # Note: "Clock Colon Blink" switch is defined in vertical-clock-core.yaml
  # Note: "Page Rotation: Vertical Clock Page" switch is defined in vertical-clock-core.yaml
  # Note: "Page Rotation: AirQ Page" switch is defined in airq-core.yaml
  # Note: "Page Rotation: WiFi Page" switch is defined in wifi-core.yaml

  # Page rotation selection switches
  - platform: template
    name: "Page Rotation: Vertical Clock Page"
    id: page_rotation_vertical_clock_switch
    icon: mdi:clock-outline
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(page_rotation_vertical_clock_enabled) = true;'
      - logger.log: "Vertical clock page enabled in rotation"
    on_turn_off:
      - lambda: 'id(page_rotation_vertical_clock_enabled) = false;'
      - logger.log: "Vertical clock page disabled in rotation"

  # Clock format and display options
  - platform: template
    name: "24h Clock Format"
    id: time_format
    icon: mdi:clock-digital
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: "config"

  - platform: template
    name: "Clock Colon Blink"
    id: colon_blink_enabled
    icon: mdi:timer-outline
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
  
  - platform: template
    name: "Page Rotation: Weather Page"
    id: page_rotation_weather_switch
    icon: mdi:weather-partly-cloudy
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(page_rotation_weather_enabled) = true;'
      - logger.log: "Weather page enabled in rotation"
      # Force immediate display update when page rotation is enabled
      - if:
          condition:
            lambda: 'return id(current_page_index) == 3;'  # Only if on weather page
          then:
            - script.execute: update_weather_icon_color
    on_turn_off:
      - lambda: 'id(page_rotation_weather_enabled) = false;'
      - logger.log: "Weather page disabled in rotation"

  - platform: template
    name: "Page Rotation: Daily Forecast Page"
    id: page_rotation_daily_forecast_switch
    icon: mdi:calendar-today
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(page_rotation_daily_forecast_enabled) = true;'
      - logger.log: "Daily forecast page enabled in rotation"
      # Force immediate display update when page rotation is enabled
      - if:
          condition:
            lambda: 'return id(current_page_index) == 4;'  # Only if on daily forecast page
          then:
            - script.execute: update_weather_icon_color
    on_turn_off:
      - lambda: 'id(page_rotation_daily_forecast_enabled) = false;'
      - logger.log: "Daily forecast page disabled in rotation"

  - platform: template
    name: "Page Rotation: Hourly Forecast Page"
    id: page_rotation_hourly_forecast_switch
    icon: mdi:clock-time-eight-outline
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(page_rotation_hourly_forecast_enabled) = true;'
      - logger.log: "Hourly forecast page enabled in rotation"
      # Force immediate display update when page rotation is enabled
      - if:
          condition:
            lambda: 'return id(current_page_index) == 5;'  # Only if on hourly forecast page
          then:
            - script.execute: update_weather_icon_color
    on_turn_off:
      - lambda: 'id(page_rotation_hourly_forecast_enabled) = false;'
      - logger.log: "Hourly forecast page disabled in rotation"

select:
  - platform: template
    name: Display Temperature Unit
    id: display_temperature_unit
    entity_category: "Config"
    options:
     - "Fahrenheit"
     - "Celsius"
     - "Kelvin"
    initial_option: "Fahrenheit"
    restore_value: true
    optimistic: true
    on_value:
      - globals.set:
          id: temp_unit_changed
          value: "true"

  - platform: template
    name: LED Effect
    id: led_effect_select
    entity_category: "Config"
    options:
      - "None"
      - "Rainbow Effect With Custom Values"
      - "Addressable Rainbow"
      - "Color Wipe"
      - "Scan"
      - "Twinkle"
      - "Fireworks"
      - "Strobe"
      - "Random Twinkle"
      - "AQI Color"
      - "Weather Condition"
      - "Auto Context"
      # Note: "AQI Color" requires airq-core.yaml to be enabled. When disabled (airq-stubs), selecting it safely turns light off
      # Note: "Weather Condition" and "Auto Context" require weather-core.yaml to be enabled. When disabled, selecting them safely turns light off
    initial_option: "None"
    restore_value: true
    optimistic: true
    on_value:
      - lambda: |-
          // Don't apply effects during boot - let startup_light_blink handle it
          if (!id(boot_complete)) return;

          std::string effect = id(led_effect_select).state;
          if (effect == "None") {
            auto call = id(rgb_light).turn_off();
            call.perform();
          } else if (effect == "AQI Color") {
            float aqi = id(computed_halo_aqi).state;
            if (std::isnan(aqi) || aqi <= 50) {
              auto call = id(rgb_light).turn_off();
              call.perform();
            } else {
              Color color;
              if (aqi <= 100) color = Color(255, 255, 0); // yellow
              else if (aqi <= 150) color = Color(255, 165, 0); // orange
              else if (aqi <= 200) color = Color(255, 0, 0); // red
              else if (aqi <= 300) color = Color(128, 0, 128); // purple
              else color = Color(128, 0, 0); // maroon
              auto call = id(rgb_light).turn_on();
              call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
              call.perform();
            }
          } else {
            // Standard effects
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          }
  
  - platform: template
    name: "Default Page at Boot"
    id: default_page_select_boot
    optimistic: true
    options:
      - "Vertical Clock"
      # Uncomment based on enabled features:
      # - "AirQ"          # if airq_enabled
      # - "WiFi"          # if wifi_enabled
      - "Weather"       # if weather_enabled
    initial_option: "Vertical Clock"
    restore_value: true

# ============================================================================
# DEFAULT PAGE SELECTOR
# ============================================================================
# Note: The default page selector must be defined in device-specific files
# (e.g., halo-v1-79e384.yaml) to match the enabled LVGL pages for that device.
# This allows each device to have only the page options that are actually available.

interval:
  - interval: 3s  # Reduced from 1s to decrease SPI bus contention
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete);'
          then:
            - script.execute: time_update

  # Note: 1s interval for colon blink is defined in vertical-clock-core.yaml

  - interval: 1s
    then:
      - if:
          condition:
            - binary_sensor.is_off: ink_ha_connected
            - lambda: 'return id(cycleCounter) < 30;'
            - switch.is_on: startup_light_blink

          then:
            - light.turn_on:
                id: rgb_light
                effect: "Addressable Rainbow"
            - lambda: 'id(cycleCounter) += 1;'

  - interval: 1s
    then:
      - if:
          condition:
            - binary_sensor.is_off: ink_ha_connected
            - lambda: 'return id(cycleCounter) > 30;'
            - lambda: 'return id(cycleCounter) < 31;'
            - switch.is_on: startup_light_blink

          then:
            - light.turn_off:
                id: rgb_light
            - lambda: 'id(cycleCounter) += 1;'

  # Batched sensor UI update - prevents LVGL cascade rendering
  - interval: 2s
    then:
      - lambda: |-
          // Only update if sensors changed since last batch
          if (id(sensor_ui_dirty)) {
            const uint32_t now = millis();
            // Ensure minimum 2s between UI refreshes
            if ((now - id(last_sensor_ui_update)) >= 2000) {
              ESP_LOGD("sensor_batch", "Batched sensor UI update triggered");
              id(sensor_ui_dirty) = false;
              id(last_sensor_ui_update) = now;
            }
          }

  # Automatic page rotation - controllable via Home Assistant with custom page selection and order
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
              if (!id(boot_complete)) return false;
              // Only rotate if auto rotation is enabled
              if (!id(auto_page_rotation_enabled)) return false;

              const uint32_t now = millis();
              const uint32_t interval_ms = id(auto_page_rotation_interval) * 1000;

              // Check if enough time has passed since last rotation
              if ((now - id(last_auto_rotation_time)) < interval_ms) return false;

              // Build separate parallel arrays for page info
              std::vector<int> page_orders;
              std::vector<int> page_indices;  // Maps to the page in sorted order

              // Collect enabled pages with their orders (use index to identify page)
              // Index: 0=vertical_clock, 1=AirQ, 2=wifi, 3=weather, 4=hourly_forecast, 5=daily_forecast

              // Core pages
              if (id(page_rotation_vertical_clock_enabled)) {
                page_orders.push_back(id(page_rotation_vertical_clock_order));
                page_indices.push_back(0);
              }
              // AirQ page (conditionally available based on AirQ package)
              // This global is provided by either airq-core.yaml or airq-stubs.yaml
              if (id(page_rotation_AirQ_enabled)) {
                page_orders.push_back(id(page_rotation_AirQ_order));
                page_indices.push_back(1);
              }
              // WiFi page (conditionally available based on WiFi package)
              // This global is provided by either wifi-core.yaml or wifi-stubs.yaml
              if (id(page_rotation_wifi_enabled)) {
                page_orders.push_back(id(page_rotation_wifi_order));
                page_indices.push_back(2);
              }

              // Weather pages (conditionally available based on weather package)
              // These globals are provided by either weather-core.yaml or weather-stubs.yaml
              if (id(page_rotation_weather_enabled)) {
                page_orders.push_back(id(page_rotation_weather_order));
                page_indices.push_back(3);
              }
              if (id(page_rotation_hourly_forecast_enabled)) {
                page_orders.push_back(id(page_rotation_hourly_forecast_order));
                page_indices.push_back(4);
              }
              if (id(page_rotation_daily_forecast_enabled)) {
                page_orders.push_back(id(page_rotation_daily_forecast_order));
                page_indices.push_back(5);
              }

              // If no pages are enabled, don't rotate
              if (page_orders.empty()) {
                ESP_LOGW("page_rotation", "No pages enabled for rotation");
                return false;
              }

              // Sort indices based on their order numbers (bubble sort for simplicity)
              for (size_t i = 0; i < page_orders.size(); i++) {
                for (size_t j = i + 1; j < page_orders.size(); j++) {
                  if (page_orders[j] < page_orders[i]) {
                    std::swap(page_orders[i], page_orders[j]);
                    std::swap(page_indices[i], page_indices[j]);
                  }
                }
              }

              // Use a static variable to track position in rotation sequence
              static int rotation_position = 0;

              // Make sure rotation_position is within bounds
              if (rotation_position >= page_indices.size()) {
                rotation_position = 0;
              }

              // Get the next page to show
              int next_page_id = page_indices[rotation_position];

              // Store the next page ID in current_page_index for the action to use
              id(current_page_index) = next_page_id;

              // Advance rotation position for next time (wrap around)
              rotation_position = (rotation_position + 1) % page_indices.size();

              // Show the next page
              ESP_LOGD("page_rotation", "Rotating to page index %d (order: %d)",
                       next_page_id, page_orders[rotation_position > 0 ? rotation_position - 1 : page_orders.size() - 1]);

              id(last_auto_rotation_time) = now;
              return true;
          then:
            # Note: Core no longer shows pages - device files must handle this
            # The rotation logic above sets current_page_index, but device files
            # must implement their own interval to actually show the pages
            - logger.log:
                format: "Core: Rotation scheduled to page index %d"
                args: ['id(current_page_index)']
                level: DEBUG

  # Colon blink interval - runs every second when on vertical clock page
  - interval: 1s
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete) && id(current_page_index) == 0;'  # vertical_clock_page
          then:
            - lambda: |-
                if (id(colon_blink_enabled).state) {
                  id(colon_blink_state) = !id(colon_blink_state);
                } else if (!id(colon_blink_state)) {
                  id(colon_blink_state) = true;
                }
            - script.execute: update_colon_widget

  # Auto-refresh weather data periodically while viewing weather page
  - interval: ${weather_refresh_interval}s
    then:
      - if:
          condition:
            lambda: 'return id(weather_on_weather_page);'
          then:
            - logger.log: "Auto-refreshing weather data..."
            - script.execute: fetch_weather_data

  - interval: 100ms  # Check frequently for page index changes
    then:
      - if:
          condition:
            lambda: |-
              static int last_displayed_index = -1;

              // Don't do anything until boot is complete
              if (!id(boot_complete)) return false;

              // Check if page index has changed
              int current = id(current_page_index);
              if (current == last_displayed_index) return false;

              // Page index changed
              last_displayed_index = current;
              ESP_LOGD("page_rotation", "Page index changed to %d", current);
              return true;
          then:
            # Page 0: vertical_clock_page
            - if:
                condition:
                  lambda: 'return id(current_page_index) == 0;'
                then:
                  - logger.log: "Page rotation: Showing vertical_clock_page (index 0)"
                  - lvgl.page.show:
                      id: vertical_clock_page
                      animation: OUT_LEFT
                      time: 300ms
                else:
                  # Page 3: weather_forecast_page
                  - if:
                      condition:
                        lambda: 'return id(current_page_index) == 3;'
                      then:
                        - logger.log: "Page rotation: Showing weather_forecast_page (index 3)"
                        - lvgl.page.show:
                            id: weather_forecast_page
                            animation: OUT_LEFT
                            time: 300ms
                      else:
                        # Unknown page - fall back to vertical clock
                        - logger.log:
                            format: "Page rotation: Page index %d not available, falling back to Vertical Clock"
                            args: ['id(current_page_index)']
                            level: WARN
                        - lvgl.page.show:
                            id: vertical_clock_page
                            animation: OUT_LEFT
                            time: 300ms

api:
  reboot_timeout: 0s  # Disable auto-reboot on API disconnect
  # Increase buffer sizes to handle sensor bursts
  # Default buffer is ~2KB, increase to 8KB
  # This prevents TCP buffer exhaustion during sensor cascades
  on_client_connected:
      - delay: 1s
      - lambda: 'id(cycleCounter) = 30;'
      - lambda: 'id(boot_complete) = true;'
      # Re-apply the saved LED effect selection after HA connects
      - delay: 2s
      - lambda: |-
          std::string effect = id(led_effect_select).state;
          if (effect == "None") {
            auto call = id(rgb_light).turn_off();
            call.perform();
          } else if (effect == "AQI Color") {
            float aqi = id(computed_halo_aqi).state;
            if (std::isnan(aqi) || aqi <= 50) {
              auto call = id(rgb_light).turn_off();
              call.perform();
            } else {
              Color color;
              if (aqi <= 100) color = Color(255, 255, 0);
              else if (aqi <= 150) color = Color(255, 165, 0);
              else if (aqi <= 200) color = Color(255, 0, 0);
              else if (aqi <= 300) color = Color(128, 0, 128);
              else color = Color(128, 0, 0);
              auto call = id(rgb_light).turn_on();
              call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
              call.perform();
            }
          } else if (effect == "Weather Condition" || effect == "Auto Context") {
            // New lambda effects - activate them
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          } else {
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          }
      - delay: 500ms
      # Note: BLE tracker start/stop on API connection is defined in ble-core.yaml

# Note: API services section removed - feature-specific services are defined in their respective packages

i2c:
  - sda: 9
    scl: 48
    id: lily_i2c
  - sda: 15
    scl: 10
    id: touch_i2c

output:
  - platform: ledc
    pin: 1
    id: backlight
    frequency: 100Hz  #Datasheet suggests low-frequency PWM. Should prevent stability issues.
    
# sy6970:
#   i2c_id: touch_i2c
#   state_led_enable: false  # To turn off the blinking green status LED

display:
  - platform: qspi_dbi
    id: lily_display
    model: AXS15231
    data_rate: 5MHz
    spi_id: lily_spi
    dimensions:
      height: 640
      width: 180
    cs_pin: 12
    reset_pin: 16
    rotation: 0
    auto_clear_enabled: false

# Touchscreen re-enabled with protective measures:
# - 100ms internal rate limiter in axs15231_touchscreen.cpp
# - Interrupt-only mode (no continuous polling)
# - 5s debounce to filter phantom touches
# - Coordinate validation to reject invalid touches
touchscreen:
  - platform: axs15231
    id: lily_touch
    display: lily_display
    i2c_id: touch_i2c
    interrupt_pin: GPIO11
    update_interval: never  # Interrupt-only mode - rely solely on hardware interrupts, no polling
    transform:
      mirror_x: false
      mirror_y: false
      swap_xy: false
    on_touch:
      - lambda: |-
          // Validate touch coordinates - filter out spurious/phantom touches
          if (touch.x < 0 || touch.x > 180 || touch.y < 0 || touch.y > 640) {
            ESP_LOGW("touch", "Invalid touch coordinates: x=%d, y=%d - ignoring", touch.x, touch.y);
            return;
          }
          ESP_LOGI("touch", "Touch at x=%d, y=%d", touch.x, touch.y);

          // Reset auto-rotation timer on any valid touch to prevent interruption during manual navigation
          id(last_auto_rotation_time) = millis();
          ESP_LOGD("touch", "Auto-rotation timer reset");

web_server:
  port: 80

image:
  - file: https://yashmulgaonkar.github.io/assets/YM.png
    id: ym_logo
    resize: 25x25
    type: RGB565
    transparency: alpha_channel

color:
  - id: my_red
    red: 100%
    green: 0%
    blue: 0%
  - id: my_yellow
    red: 100%
    green: 100%
    blue: 0%
  - id: my_green
    red: 0%
    green: 100%
    blue: 0%
  - id: my_blue
    red: 0%
    green: 0%
    blue: 100%
  - id: my_gray
    red: 50%
    green: 50%
    blue: 50%
  - id: my_orange
    red: 100%
    green: 50%
    blue: 0%
  - id: my_teal
    red: 0%
    green: 100%
    blue: 100%
  - id: my_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_black
    red: 0%
    green: 0%
    blue: 0%

# HTTP Request component for calling HA REST API
http_request:
  useragent: esphome/halo
  timeout: 10s

time:
  - platform: homeassistant
    id: ha_time
    on_time_sync:
      - script.execute: time_update
  - platform: sntp
    id: sntp_time
    timezone: America/New_York
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
      - 2.pool.ntp.org
    on_time_sync:
      - script.execute: time_update

script:
  - id: page_transition_cleanup
    mode: queued  # Queue executions instead of warning about duplicates
    max_runs: 2   # Allow up to 2 queued runs
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete) && !id(ota_in_progress);'
          then:
            - delay: 50ms  # Small delay to prevent rapid successive calls
            - lambda: |-
                // Safety check: Only run if LVGL is fully initialized
                lv_obj_t *scr = lv_scr_act();
                if (scr == NULL) {
                  return;  // Silently skip if not initialized
                }

                // Log current memory state before cleanup
                ESP_LOGD("lvgl", "Page transition cleanup - Free heap: %d", esp_get_free_heap_size());

                // Clear all cached strings to free memory
                id(time_update_last_text).clear();
                id(weather_last_condition).clear();

                // Force LVGL to invalidate current screen and redraw
                lv_obj_invalidate(scr);

                // Force immediate display flush to prevent buffer buildup
                lv_refr_now(NULL);

  - id: update_colon_widget
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(colon_blink_state);'
          then:
            - lvgl.label.update:
                id: vclock_colon
                text: ":"
          else:
            - lvgl.label.update:
                id: vclock_colon
                text: " "

  - id: update_weather_icon_color
    mode: restart
    then:
      - lambda: |-
          id(weather_last_started) = millis();
          id(weather_needs_render) = false;
      - lambda: |-
          std::string condition = id(weather_current_condition);
          ESP_LOGD("weather_color", "Current condition: '%s'", condition.c_str());
          if (condition.empty()) {
            return;
          }
          std::string normalized = condition;
          std::transform(normalized.begin(), normalized.end(), normalized.begin(), ::tolower);
          if (normalized != id(weather_last_condition)) {
            id(weather_last_condition) = normalized;
            id(weather_needs_render) = true;
          }
      - if:
          condition:
            lambda: 'return id(weather_needs_render);'
          then:
            - lvgl.label.update:
                id: lbl_weather_forecast_condition_icon
                text_color: !lambda |-
                  const std::string condition = id(weather_last_condition);
                  ESP_LOGD("weather_color", "Applying color for condition: '%s'", condition.c_str());
                  if (condition.find("clear-night") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Slate Blue color (night)");
                    return lv_color_hex(0x6A5ACD);
                  } else if (condition.find("sunny") != std::string::npos || condition.find("clear") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Gold color");
                    return lv_color_hex(0xFFD700);
                  } else if (condition.find("snowy-rainy") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Light Cyan color (mixed precipitation)");
                    return lv_color_hex(0xAFEEEE);
                  } else if (condition.find("lightning-rainy") != std::string::npos || condition.find("lightning") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Deep Pink color");
                    return lv_color_hex(0xFF1493);
                  } else if (condition.find("partlycloudy") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Light Sky Blue color");
                    return lv_color_hex(0x87CEFA);
                  } else if (condition.find("cloudy") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Dark Gray color");
                    return lv_color_hex(0xA9A9A9);
                  } else if (condition.find("rainy") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Royal Blue color");
                    return lv_color_hex(0x4169E1);
                  } else if (condition.find("snowy") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Gainsboro color");
                    return lv_color_hex(0xDCDCDC);
                  } else if (condition.find("fog") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Light Steel Blue color");
                    return lv_color_hex(0xB0C4DE);
                  } else if (condition.find("windy") != std::string::npos) {
                    ESP_LOGD("weather_color", "Setting Light Green color");
                    return lv_color_hex(0x90EE90);
                  } else {
                    ESP_LOGD("weather_color", "Setting White color (default)");
                    return lv_color_hex(0xFFFFFF);
                  }
      - lambda: |-
          const uint32_t elapsed = millis() - id(weather_last_started);
          id(weather_last_duration) = elapsed;
          const bool rendered = id(weather_needs_render);
          if (elapsed > 80) {
            ESP_LOGW("weather_color", "update_weather_icon_color took %u ms (rendered=%s)", elapsed, rendered ? "true" : "false");
          } else {
            ESP_LOGD("weather_color", "update_weather_icon_color took %u ms (rendered=%s)", elapsed, rendered ? "true" : "false");
          }
          id(weather_needs_render) = false;

  # ============================================================================
  # WORKAROUND: HTTP-based weather fetch for HA 2025.10.x compatibility
  # ============================================================================
  # ESPHome 2025.10.3's homeassistant.action with capture_response doesn't work
  # with HA 2025.10.x's new weather.get_forecasts action format.
  # GitHub Issue: https://github.com/esphome/issues/issues/XXXXX (to be filed)
  # 
  # This uses direct HTTP calls to HA's REST API instead.
  # Requires: ha_url and ha_token in substitutions
  # ============================================================================

  # Main script to fetch all weather data via HA REST API
  - id: fetch_weather_data
    mode: single
    then:
      - logger.log: "Fetching weather data from Home Assistant via HTTP..."

      # Fetch daily forecast
      - http_request.post:
          url: !lambda |-
            return "${ha_url}/api/services/weather/get_forecasts?return_response=true";
          request_headers:
            Content-Type: application/json
            Authorization: !lambda |-
              return "Bearer ${ha_token}";
          body: !lambda |-
            return "{\"entity_id\":\"${weather_entity_id}\",\"type\":\"daily\"}";
          on_response:
            then:
              - lambda: |-
                  // Read response body first (for both success and error cases)
                  std::string body_str;
                  body_str.reserve(response->content_length);
                  uint8_t buffer[512];
                  while (response->get_bytes_read() < response->content_length) {
                    int read_len = response->read(buffer, sizeof(buffer));
                    if (read_len > 0) {
                      body_str.append((char*)buffer, read_len);
                    }
                  }

                  // response is already provided by ESPHome http_request
                  if (response->status_code != 200) {
                    ESP_LOGE("weather", "✗ Daily forecast HTTP failed: %d", response->status_code);
                    ESP_LOGE("weather", "Error response body: %s", body_str.c_str());
                    return;
                  }

                  ESP_LOGI("weather", "✓ Daily forecast HTTP response received");
                  
                  // Parse JSON response
                  JsonDocument doc;
                  DeserializationError error = deserializeJson(doc, body_str);
                  
                  if (error) {
                    ESP_LOGE("weather", "JSON parse error: %s", error.c_str());
                    return;
                  }

                  // Response format: {"weather.hhut": {"forecast": [...]}}
                  const char *entity_key = "${weather_entity_id}";
                  
                  if (!doc[entity_key].is<JsonObject>()) {
                    ESP_LOGE("weather", "Entity '%s' not found in response", entity_key);
                    return;
                  }

                  JsonObject entity_data = doc[entity_key];
                  
                  if (!entity_data["forecast"].is<JsonArray>()) {
                    ESP_LOGW("weather", "No 'forecast' key in daily response");
                    return;
                  }

                  JsonArray forecast_array = entity_data["forecast"];
                  int day_count = std::min((int)forecast_array.size(), 10);
                  ESP_LOGI("weather", "Found %d days of forecast data", day_count);

                  for (int i = 0; i < day_count; i++) {
                    JsonObject day = forecast_array[i];

                    if (day["temperature"].is<float>()) {
                      id(weather_forecast_temp_high)[i] = day["temperature"].as<float>();
                    }

                    if (day["templow"].is<float>()) {
                      id(weather_forecast_temp_low)[i] = day["templow"].as<float>();
                    }

                    if (day["condition"].is<const char*>()) {
                      id(weather_forecast_condition)[i] = day["condition"].as<std::string>();
                    }

                    if (day["precipitation_probability"].is<float>()) {
                      id(weather_forecast_precip_prob)[i] = day["precipitation_probability"].as<float>();
                    }
                  }
                  ESP_LOGI("weather", "✓ Daily forecast stored successfully");

      # Fetch hourly forecast
      - http_request.post:
          url: !lambda |-
            return "${ha_url}/api/services/weather/get_forecasts?return_response=true";
          request_headers:
            Content-Type: application/json
            Authorization: !lambda |-
              return "Bearer ${ha_token}";
          body: !lambda |-
            return "{\"entity_id\":\"${weather_entity_id}\",\"type\":\"hourly\"}";
          on_response:
            then:
              - lambda: |-
                  // Read response body first (for both success and error cases)
                  std::string body_str;
                  body_str.reserve(response->content_length);
                  uint8_t buffer[512];
                  while (response->get_bytes_read() < response->content_length) {
                    int read_len = response->read(buffer, sizeof(buffer));
                    if (read_len > 0) {
                      body_str.append((char*)buffer, read_len);
                    }
                  }

                  // response is already provided by ESPHome http_request
                  if (response->status_code != 200) {
                    ESP_LOGE("weather", "✗ Hourly forecast HTTP failed: %d", response->status_code);
                    ESP_LOGE("weather", "Error response body: %s", body_str.c_str());
                    return;
                  }

                  ESP_LOGI("weather", "✓ Hourly forecast HTTP response received");
                  
                  // Parse JSON response
                  JsonDocument doc;
                  DeserializationError error = deserializeJson(doc, body_str);
                  
                  if (error) {
                    ESP_LOGE("weather", "JSON parse error: %s", error.c_str());
                    return;
                  }

                  // Response format: {"weather.hhut": {"forecast": [...]}}
                  const char *entity_key = "${weather_entity_id}";
                  
                  if (!doc[entity_key].is<JsonObject>()) {
                    ESP_LOGE("weather", "Entity '%s' not found in response", entity_key);
                    return;
                  }

                  JsonObject entity_data = doc[entity_key];
                  
                  if (!entity_data["forecast"].is<JsonArray>()) {
                    ESP_LOGW("weather", "No 'forecast' key in hourly response");
                    return;
                  }

                  JsonArray forecast_array = entity_data["forecast"];
                  int hour_count = std::min((int)forecast_array.size(), 24);
                  ESP_LOGI("weather", "Found %d hours of forecast data", hour_count);

                  for (int i = 0; i < hour_count; i++) {
                    JsonObject hour = forecast_array[i];

                    if (hour["temperature"].is<float>()) {
                      id(weather_hourly_temp)[i] = hour["temperature"].as<float>();
                    }

                    if (hour["apparent_temperature"].is<float>()) {
                      id(weather_hourly_apparent_temp)[i] = hour["apparent_temperature"].as<float>();
                    }

                    if (hour["condition"].is<const char*>()) {
                      id(weather_hourly_condition)[i] = hour["condition"].as<std::string>();
                    }

                    if (hour["precipitation_probability"].is<float>()) {
                      id(weather_hourly_precip_prob)[i] = hour["precipitation_probability"].as<float>();
                    }
                  }
                  ESP_LOGI("weather", "✓ Hourly forecast stored successfully");

      - lambda: |-
          // Update timestamp
          id(weather_last_update) = millis();
          ESP_LOGI("weather", "✓ Weather forecast data fetch complete!");

      # Update the display after fetching data
      - script.execute: update_weather_display

  # Script to update LVGL display with fetched data
  - id: update_weather_display
    mode: single
    then:
      - lvgl.label.update:
          id: lbl_weather_forecast_condition_name
          text: !lambda |-
            if (id(weather_current_condition).empty()) {
              return std::string("Unknown");
            }
            return id(weather_current_condition);

      - lvgl.label.update:
          id: lbl_weather_today_outdoor_temp
          text: !lambda |-
            if (isnan(id(weather_current_temp))) {
              return std::string("--.- °F");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.1f °F", id(weather_current_temp));
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_today_tempap
          text: !lambda |-
            if (isnan(id(weather_current_apparent_temp))) {
              return std::string("--°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.0f°", id(weather_current_apparent_temp));
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_forecast_temphi
          text: !lambda |-
            if (isnan(id(weather_forecast_temp_high)[0])) {
              return std::string("H: --°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "H: %.0f°", id(weather_forecast_temp_high)[0]);
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_forecast_templo
          text: !lambda |-
            if (isnan(id(weather_forecast_temp_low)[0])) {
              return std::string("L: --°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "L: %.0f°", id(weather_forecast_temp_low)[0]);
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_today_dailyprecipprob
          text: !lambda |-
            if (isnan(id(weather_forecast_precip_prob)[0])) {
              return std::string("Chance: --%");
            }
            char buf[32];
            snprintf(buf, sizeof(buf), "Chance: %.0f%%", id(weather_forecast_precip_prob)[0]);
            return std::string(buf);

      - logger.log: "✓ Weather display labels updated"

  - id: time_update
    mode: restart
    then:
      - lambda: |-
          id(time_update_last_started) = millis();
          id(time_update_needs_render) = false;
      - lambda: |-
          auto now = id(ha_time).now();
          if (!now.is_valid()) {
            ESP_LOGW("time_update", "Time source unavailable, skipping label update");
            return;
          }
          bool is_pm = now.hour >= 12;
          int hour_12 = now.hour % 12;
          if (hour_12 == 0) {
            hour_12 = 12;
          }
          char time_buf[17];
          if (id(time_format).state) {
            snprintf(time_buf, sizeof(time_buf), "%02d:%02d", now.hour, now.minute);
          } else {
            snprintf(time_buf, sizeof(time_buf), "%2d:%02d%s", hour_12, now.minute, is_pm ? "PM" : "AM");
          }
          std::string new_text(time_buf);
          if (new_text != id(time_update_last_text)) {
            id(time_update_last_text) = new_text;
            id(time_update_needs_render) = true;
          }
      # Update vertical clock page (page index 0)
      - if:
          condition:
            lambda: 'return id(time_update_needs_render) && id(current_page_index) == 0;'
          then:
            - lvgl.label.update:
                id: vclock_hours
                text: !lambda |-
                  auto now = id(ha_time).now();
                  if (!now.is_valid()) return std::string("--");
                  bool is_pm = now.hour >= 12;
                  int hour_12 = now.hour % 12;
                  if (hour_12 == 0) hour_12 = 12;
                  char buf[3];
                  if (id(time_format).state) {
                    snprintf(buf, sizeof(buf), "%02d", now.hour);
                  } else {
                    snprintf(buf, sizeof(buf), "%2d", hour_12);
                  }
                  return std::string(buf);
            - lvgl.label.update:
                id: vclock_minutes
                text: !lambda |-
                  auto now = id(ha_time).now();
                  if (!now.is_valid()) return std::string("--");
                  char buf[3];
                  snprintf(buf, sizeof(buf), "%02d", now.minute);
                  return std::string(buf);
            - lvgl.label.update:
                id: vclock_ampm
                text: !lambda |-
                  auto now = id(ha_time).now();
                  if (!now.is_valid()) return std::string("");
                  if (id(time_format).state) return std::string("");
                  bool is_pm = now.hour >= 12;
                  return std::string(is_pm ? "PM" : "AM");
            - lvgl.label.update:
                id: vclock_date
                text: !lambda |-
                  auto now = id(ha_time).now();
                  if (!now.is_valid()) return std::string("--");
                  static const char* months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
                  char buf[20];
                  snprintf(buf, sizeof(buf), "%s %d", months[now.month - 1], now.day_of_month);
                  return std::string(buf);
            - lvgl.label.update:
                id: vclock_day_top
                text: !lambda |-
                  auto now = id(ha_time).now();
                  if (!now.is_valid()) return std::string("--");
                  static const char* days[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
                  return std::string(days[now.day_of_week - 1]);
      - script.execute: update_colon_widget
      - lambda: |-
          const uint32_t elapsed = millis() - id(time_update_last_started);
          id(time_update_last_duration) = elapsed;
          const bool rendered = id(time_update_needs_render);
          if (elapsed > 40) {
            ESP_LOGW("time_update", "time_update took %u ms (rendered=%s)", elapsed, rendered ? "true" : "false");
          } else {
            ESP_LOGD("time_update", "time_update took %u ms (rendered=%s)", elapsed, rendered ? "true" : "false");
          }
          id(time_update_needs_render) = false;

number:
  - platform: template
    name: "Auto Page Rotation Interval"
    id: page_rotation_interval
    icon: mdi:timer
    restore_value: true
    initial_value: 30
    min_value: 5
    max_value: 300
    entity_category: "config"
    unit_of_measurement: "s"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(auto_page_rotation_interval) = (int)x;'
      - logger.log:
          format: "Page rotation interval changed to %d seconds"
          args: ['(int)x']

  # Page rotation order numbers (1-6, lower numbers show first)
  # Note: "Page Order: Vertical Clock Page" number is defined in vertical-clock-core.yaml
  # Note: "Page Order: AirQ Page" number is defined in airq-core.yaml
  # Note: "Page Order: WiFi Page" number is defined in wifi-core.yaml
  # Note: SEN55 Temperature/Humidity Offset numbers are defined in airq-core.yaml

  # Page rotation order numbers (1-6, lower numbers show first)
  - platform: template
    name: "Page Order: Vertical Clock Page"
    id: page_order_vertical_clock
    icon: mdi:numeric
    restore_value: true
    initial_value: 6
    min_value: 1
    max_value: 6
    entity_category: "config"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(page_rotation_vertical_clock_order) = (int)x;'
      - logger.log:
          format: "Vertical clock page order set to %d"
          args: ['(int)x']

  - platform: template
    name: "Page Order: Weather Page"
    id: page_order_weather
    icon: mdi:numeric
    restore_value: true
    initial_value: 3
    min_value: 1
    max_value: 6
    entity_category: "config"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(page_rotation_weather_order) = (int)x;'
      - logger.log:
          format: "Weather page order set to %d"
          args: ['(int)x']
      # Force immediate display update when page order changes
      - if:
          condition:
            lambda: 'return id(current_page_index) == 3;'  # Only if on weather page
          then:
            - script.execute: update_weather_icon_color

  - platform: template
    name: "Page Order: Daily Forecast Page"
    id: page_order_daily_forecast
    icon: mdi:numeric
    restore_value: true
    initial_value: 4
    min_value: 1
    max_value: 6
    entity_category: "config"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(page_rotation_daily_forecast_order) = (int)x;'
      - logger.log:
          format: "Daily forecast page order set to %d"
          args: ['(int)x']
      # Force immediate display update when page order changes
      - if:
          condition:
            lambda: 'return id(current_page_index) == 4;'  # Only if on daily forecast page
          then:
            - script.execute: update_weather_icon_color

  - platform: template
    name: "Page Order: Hourly Forecast Page"
    id: page_order_hourly_forecast
    icon: mdi:numeric
    restore_value: true
    initial_value: 5
    min_value: 1
    max_value: 6
    entity_category: "config"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(page_rotation_hourly_forecast_order) = (int)x;'
      - logger.log:
          format: "Hourly forecast page order set to %d"
          args: ['(int)x']
      # Force immediate display update when page order changes
      - if:
          condition:
            lambda: 'return id(current_page_index) == 5;'  # Only if on hourly forecast page
          then:
            - script.execute: update_weather_icon_color

  # Weather gauge control (for weather page needle)
  - platform: template
    name: "Weather Gauge Value"
    id: weather_gauge_value
    min_value: 0
    max_value: 100
    step: 1
    mode: box
    optimistic: true
    entity_category: config
    icon: mdi:gauge
    unit_of_measurement: "%"
    on_value:
      - lvgl.indicator.update:
          id: weather_temp_needle
          value: !lambda 'return (int)x;'

binary_sensor:
  - platform: status
    name: Online
    id: ink_ha_connected

  - platform: template
    name: "Display Backlight Active"
    id: display_backlight_state
    entity_category: "diagnostic"
    lambda: 'return id(display_backlight_is_on);'

sensor:
  # Display refresh rate monitor
  - platform: template
    name: "Display Refresh Count"
    id: display_refresh_counter
    internal: true
    update_interval: never
    entity_category: "diagnostic"

  - platform: uptime
    name: Uptime
    id: sys_uptime
    update_interval: 60s

  # Note: wifi_signal (RSSI) sensor is defined in wifi-core.yaml

  - platform: template
    name: "Time Update Duration"
    id: time_update_duration_sensor
    internal: true  # Don't send to Home Assistant - internal diagnostic only
    unit_of_measurement: "ms"
    accuracy_decimals: 0
    icon: "mdi:timer-outline"
    entity_category: "diagnostic"
    update_interval: never
  
  - platform: template
    name: "Computed AQI (Stub)"
    id: computed_halo_aqi
    internal: true
    update_interval: never
    accuracy_decimals: 0
    lambda: 'return NAN;'  # Always return NaN (not a number)

  # Weather Icon Update Duration sensor moved to packages/weather-core.yaml
  # AirQ sensors (computed_aqi, scd4x, mics_4514, bme280, sen5x) moved to packages/airq-core.yaml
  # Weather sensors removed - now in packages/weather-sensors.yaml

  - platform: template
    name: "Weather Icon Update Duration"
    id: weather_icon_duration_sensor
    internal: true  # Don't send to Home Assistant - internal diagnostic only
    unit_of_measurement: "ms"
    accuracy_decimals: 0
    icon: "mdi:weather-lightning"
    entity_category: "diagnostic"
    update_interval: never

  # Internal heap monitoring
  - platform: template
    name: "Free Heap"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "bytes"
    update_interval: 7s
    entity_category: "diagnostic"

  - platform: template
    name: "Largest Free Block"
    lambda: return heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "bytes"
    update_interval: 7s
    entity_category: "diagnostic"

  - platform: template
    name: "Heap Fragmentation"
    lambda: |-
      size_t free_heap = heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
      size_t largest_block = heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
      if (free_heap > 0) {
        return ((float)(free_heap - largest_block) / free_heap) * 100.0;
      }
      return 0.0;
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 7s
    entity_category: "diagnostic"

  # DMA-capable memory monitoring
  - platform: template
    name: "DMA Capable Heap Free"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_DMA);
    unit_of_measurement: "bytes"
    update_interval: 30s
    entity_category: "diagnostic"

  - platform: template
    name: "DMA Capable Largest Block"
    lambda: return heap_caps_get_largest_free_block(MALLOC_CAP_DMA);
    unit_of_measurement: "bytes"
    update_interval: 7s
    entity_category: "diagnostic"

  # PSRAM monitoring (if available)
  - platform: template
    name: "PSRAM Free"
    lambda: |-
      size_t psram_free = heap_caps_get_free_size(MALLOC_CAP_SPIRAM);
      if (psram_free > 0) {
        return psram_free;
      }
      return 0;  // No PSRAM available
    unit_of_measurement: "bytes"
    update_interval: 7s
    entity_category: "diagnostic"

  # Total free heap across all memory types
  - platform: template
    name: "Total Free Heap (All)"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_8BIT);
    unit_of_measurement: "bytes"
    update_interval: 7s
    entity_category: "diagnostic"

  # Minimum free heap since boot (indicates worst-case memory pressure)
  - platform: template
    name: "Min Free Heap Ever"
    lambda: return heap_caps_get_minimum_free_size(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "bytes"
    update_interval: 7s
    entity_category: "diagnostic"

text_sensor:
  - platform: template
    name: "Time Value (Stub)"
    id: timeVal_stub
    internal: true
    update_interval: never
# Weather icon fonts (icons_20, icons_40, icons_50, icons_80, icons_100)
# have been moved to packages/weather-pages.yaml
# Vertical clock fonts (montserrat_80, montserrat_50, montserrat_24)
# have been moved to packages/vertical-clock-core.yaml

light:
  # - platform: esp32_rmt_led_strip
  #   id: rgb_light
  #   name: "Halo"
  #   pin: GPIO47
  #   rgb_order: GRB
  #   default_transition_length: 2s
  #   chipset: SK6812
  #   num_leds: 11
  #   effects:
  #     - pulse:
  #         name: "Slow Pulse" 
  #         transition_length: 500ms
  #         update_interval: 500ms
  #         min_brightness: 10%
  #         max_brightness: 50%
  #     - addressable_rainbow:
  #         name: Rainbow Effect With Custom Values
  #         speed: 10
  #         width: 50

  - platform: esp32_rmt_led_strip
    name: Halo
    id: rgb_light
    rgb_order: GRB
    pin: GPIO47
    num_leds: 12
    chipset: WS2812
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_rainbow:
          name: Rainbow Effect With Custom Values
          speed: 10
          width: 50
      - addressable_rainbow:
          name: Addressable Rainbow
      - addressable_color_wipe:
          name: Color Wipe
      - addressable_scan:
          name: Scan
      - addressable_twinkle:
          name: Twinkle
      - addressable_fireworks:
          name: Fireworks
      - strobe:
          name: Strobe
      - addressable_random_twinkle:
          name: Random Twinkle
      # Note: "Weather Condition" and "Auto Context" LED effects removed from Core
      # These effects require weather-specific IDs (forecast_day1_condition, etc.)
      # They should be defined in weather-core.yaml package instead

  - platform: monochromatic
    output: backlight
    name: "Display Backlight"
    id: display_backlight
    restore_mode: ALWAYS_ON
    on_turn_on:
      - logger.log: "Display backlight turned ON"
      - lambda: 'id(display_backlight_is_on) = true;'
      - binary_sensor.template.publish:
          id: display_backlight_state
          state: ON
    on_turn_off:
      - logger.log: "Display backlight turned OFF"
      - lambda: 'id(display_backlight_is_on) = false;'
      - binary_sensor.template.publish:
          id: display_backlight_state
          state: OFF

lvgl:
  id: lvgl_main
  displays:
    - lily_display
  touchscreens:
    - lily_touch
  buffer_size: 30%  # Can now use larger buffers since LVGL uses PSRAM via CONFIG_LV_MEM_CUSTOM
                    # With PSRAM enabled, display buffers are allocated in external RAM
                    # This improves rendering performance without consuming internal heap
  disp_bg_color: 0x000000
  disp_bg_opa: COVER
  disp_bg_image: none
  log_level: WARN  # Reduce logging overhead

  # Gradient definitions used by WiFi pages
  gradients:
    - id: wifi_signal_gradient
      direction: hor
      dither: none
      stops:
        - color: 0xFF0000  # Red - weak signal
          position: 0
        - color: 0xFF8000  # Orange
          position: 64
        - color: 0xFFFF00  # Yellow
          position: 128
        - color: 0x80FF00  # Yellow-green
          position: 192
        - color: 0x00FF00  # Green - strong signal
          position: 255

  # IMPORTANT: Pages are now defined in device-specific configs
  # Include one of these packages in your device file:
  #   - lvgl-pages-full.yaml (all features)
  #   - lvgl-pages-airq-only.yaml (clock + AirQ)
  #   - lvgl-pages-weather.yaml (clock + weather)
  #   - lvgl-pages-clock-only.yaml (minimal clock)
  #
  # Example in device file:
  # packages:
  #   lvgl_pages:
  #     url: https://github.com/truffshuff/halo/
  #     ref: main
  #     files: [TFT_LCD/T-Display-Long/V1/Firmware/ESPHome/packages/lvgl-pages-airq-only.yaml]
  #     refresh: always
  pages:
    - id: vertical_clock_page
      bg_color: 0x000000
      bg_opa: COVER
      scrollbar_mode: "OFF"
      on_load:
        - script.execute: page_transition_cleanup
        - lambda: |-
            id(current_page_index) = 0;
            id(time_update_last_text).clear();
            id(colon_blink_state) = true;  // Ensure colon is visible when page loads
        - script.execute: time_update
        - script.execute: update_colon_widget
      widgets:
        # Large time display vertically centered
        - label:
            id: vclock_hours
            align: CENTER
            text_font: montserrat_80
            text_color: my_white
            x: 0
            y: -120
            text: "12"

        - label:
            id: vclock_colon
            align: CENTER
            text_font: montserrat_80
            text_color: my_white
            x: 0
            y: -20
            text: ":"

        - label:
            id: vclock_minutes
            align: CENTER
            text_font: montserrat_80
            text_color: my_white
            x: 0
            y: 80
            text: "00"

        - label:
            id: vclock_ampm
            align: CENTER
            text_font: montserrat_50
            text_color: my_white
            x: 0
            y: 180
            text: "AM"

        # Date below time
        - label:
            id: vclock_date
            align: CENTER
            text_font: montserrat_24
            text_color: my_gray
            x: 0
            y: 250
            text: "Mon, Jan 1"

        # Day of week at top
        - label:
            id: vclock_day_top
            align: TOP_MID
            text_font: montserrat_24
            text_color: my_gray
            x: 0
            y: 20
            text: "Monday"

        # Navigation button (top right corner)
        - obj:
            id: nav_button_vclock
            align: TOP_RIGHT
            x: 0
            y: 0
            width: 100
            height: 100
            bg_opa: 0
            border_width: 0
            clickable: true
            on_press:
              - logger.log: "Vertical Clock page nav button PRESSED!"
              - lambda: |-
                  ESP_LOGI("touch", "Navigation button touched");
                  id(last_auto_rotation_time) = millis();
                  ESP_LOGD("touch", "Auto-rotation timer reset");
              - lvgl.page.next:
                  animation: OUT_LEFT
                  time: 300ms
    
    # Weather Forecast Page (Page 3)
    # Main weather display with current conditions
    - id: weather_forecast_page
      bg_color: 0x000000
      bg_opa: COVER
      scrollbar_mode: "OFF"
      on_load:
        - script.execute: page_transition_cleanup
        - lambda: |-
            id(current_page_index) = 3;  // weather_forecast_page
            id(weather_last_condition).clear();
            id(weather_on_weather_page) = true;
        - script.execute: fetch_weather_data
        - script.execute: update_weather_icon_color
      on_unload:
        - lambda: 'id(weather_on_weather_page) = false;'
      widgets:
        # Large weather condition icon at top
        - label:
            text: "\U000F14E4"
            id: lbl_weather_forecast_condition_icon
            text_font: icons_100
            text_align: CENTER
            text_color: my_white
            align: TOP_MID
            x: 0
            y: 10

        # Condition name below icon
        - label:
            id: lbl_weather_forecast_condition_name
            text: !lambda |-
              if (id(weather_current_condition).empty()) {
                return std::string("Unknown");
              }
              return id(weather_current_condition);
            text_align: CENTER
            text_font: montserrat_20
            text_color: my_white
            align: TOP_MID
            x: 0
            y: 120

        # Semicircle meter gauge for apparent temperature
        - obj:
            align: CENTER
            x: 0
            y: 100
            width: 180
            height: 180
            bg_color: 0x000000
            border_width: 0
            pad_all: 10
            widgets:
              - meter:
                  id: weather_temp_gauge
                  height: 100%
                  width: 100%
                  border_width: 0
                  align: CENTER
                  bg_opa: TRANSP
                  scales:
                    - range_from: 0
                      range_to: 100
                      angle_range: 180
                      rotation: 180
                      ticks:
                        count: 51
                        width: 2
                        length: 10
                        color: 0x404040
                      indicators:
                        - tick_style:
                            start_value: 0
                            end_value: 100
                            color_start: 0x0099FF
                            color_end: 0xFF6600
                    - range_from: 0
                      range_to: 100
                      angle_range: 180
                      rotation: 180
                      ticks:
                        count: 0
                      indicators:
                        - line:
                            id: weather_temp_needle
                            width: 8
                            r_mod: 2
                            value: 50
                            color: 0xFF0000
              - obj:
                  height: 100
                  width: 100
                  radius: 50
                  align: CENTER
                  border_width: 0
                  bg_color: 0x000000

        # Current apparent temperature in center of gauge
        - label:
            id: lbl_weather_today_tempap
            text: !lambda |-
              if (isnan(id(weather_current_apparent_temp))) {
                return std::string("--°");
              }
              char buf[16];
              snprintf(buf, sizeof(buf), "%.0f°", id(weather_current_apparent_temp));
              return std::string(buf);
            text_align: CENTER
            text_font: montserrat_28
            text_color: my_white
            align: CENTER
            x: 0
            y: 120

        # "Feels Like" label above temp
        - label:
            text: "Feels Like"
            text_align: CENTER
            text_font: montserrat_14
            text_color: my_gray
            align: CENTER
            x: 0
            y: 95

        # Low temp stacked above gauge
        - label:
            id: lbl_weather_forecast_templo
            text: !lambda |-
              if (isnan(id(weather_forecast_temp_low)[0])) {
                return std::string("L: --°");
              }
              char buf[16];
              snprintf(buf, sizeof(buf), "L: %.0f°", id(weather_forecast_temp_low)[0]);
              return std::string(buf);
            text_align: CENTER
            text_font: montserrat_28
            text_color: my_teal
            align: CENTER
            x: 0
            y: -35

        # High temp stacked above low temp
        - label:
            id: lbl_weather_forecast_temphi
            text: !lambda |-
              if (isnan(id(weather_forecast_temp_high)[0])) {
                return std::string("H: --°");
              }
              char buf[16];
              snprintf(buf, sizeof(buf), "H: %.0f°", id(weather_forecast_temp_high)[0]);
              return std::string(buf);
            text_align: CENTER
            text_font: montserrat_28
            text_color: my_red
            align: CENTER
            x: 0
            y: -70

        # Precipitation Chance
        - label:
            id: lbl_weather_today_dailyprecipprob
            text: !lambda |-
              if (isnan(id(weather_forecast_precip_prob)[0])) {
                return std::string("Chance: --%");
              }
              char buf[32];
              snprintf(buf, sizeof(buf), "Chance: %.0f%%", id(weather_forecast_precip_prob)[0]);
              return std::string(buf);
            text_align: CENTER
            text_font: montserrat_18
            text_color: my_teal
            align: BOTTOM_MID
            x: 0
            y: -55

        # Current temperature at bottom
        - label:
            text: "Now:"
            text_align: CENTER
            text_font: montserrat_14
            text_color: my_gray
            align: BOTTOM_MID
            x: 0
            y: -30

        - label:
            id: lbl_weather_today_outdoor_temp
            text: !lambda |-
              if (isnan(id(weather_current_temp))) {
                return std::string("--.- °F");
              }
              char buf[16];
              snprintf(buf, sizeof(buf), "%.1f °F", id(weather_current_temp));
              return std::string(buf);
            text_align: CENTER
            text_font: montserrat_20
            text_color: my_white
            align: BOTTOM_MID
            x: 0
            y: -5
        - obj:
            id: nav_button_weather
            align: TOP_RIGHT
            x: 0
            y: 0
            width: 100
            height: 100
            bg_opa: 0
            border_width: 0
            clickable: true
            on_press:
              - logger.log: "Weather page nav button PRESSED!"
              - lambda: |-
                  ESP_LOGI("touch", "Navigation button touched");
                  id(last_auto_rotation_time) = millis();
                  ESP_LOGD("touch", "Auto-rotation timer reset");
              - lvgl.page.next:
                  animation: OUT_LEFT
                  time: 300ms

button:
  - platform: restart
    icon: mdi:power-cycle
    name: "ESP Reboot"

  - platform: factory_reset
    disabled_by_default: True
    name: "Factory Reset ESP"
    id: factory_reset_all

  - platform: template
    name: "Refresh Weather"
    id: btn_refresh_weather
    on_press:
      - script.execute: fetch_weather_data

  - platform: template
    name: "Debug Daily Forecast"
    id: btn_debug_daily_forecast
    on_press:
      - homeassistant.action:
          action: weather.get_forecasts
          capture_response: true
          data:
            entity_id: ${weather_entity_id}
            type: daily
          on_success:
            - lambda: |-
                JsonObjectConst root = response;
                if (response.containsKey("response")) {
                  root = response["response"].as<JsonObjectConst>();
                }

                std::string output;
                serializeJsonPretty(root, output);
                ESP_LOGI("weather", "Daily forecast:\n%s", output.c_str());
          on_error:
            - logger.log: "Daily forecast call failed"

  # - platform: template
  #   name: "Test Weather Call"
  #   id: btn_test_weather_call
  #   on_press:
  #     - homeassistant.action:
  #         action: weather.get_forecasts
  #         data:
  #           entity_id: weather.hhut
  #           type: daily
  #           return_response: true
  #         capture_response: true
  #         on_success:
  #           - lambda: |-
  #               // response is JsonObjectConst
  #               if (!response.containsKey("response")) {
  #                 ESP_LOGE("weather", "Missing 'response' key!");
  #                 return;
  #               }
  #               const auto &resp_obj = response["response"];
  #               if (!resp_obj.containsKey("weather.hhut")) {
  #                 ESP_LOGE("weather", "Missing 'weather.hhut'!");
  #                 return;
  #               }
  #               const auto &entity = resp_obj["weather.hhut"];
  #               if (!entity.containsKey("forecast")) {
  #                 ESP_LOGE("weather", "Missing 'forecast'!");
  #                 return;
  #               }
  #               const auto &forecast = entity["forecast"];
  #               for (size_t i = 0; i < forecast.size(); i++) {
  #                 const auto &day = forecast[i];
  #                 float temp = day.containsKey("temperature") ? day["temperature"].as<float>() : NAN;
  #                 const char *cond = day.containsKey("condition") ? day["condition"].as<std::string>().c_str() : "N/A";
  #                 ESP_LOGI("weather", "Day %d temp: %.1f, condition: %s", i, temp, cond);
  #               }
  #         on_error:
  #           - logger.log: "Failed to call weather.get_forecasts!"

  # - platform: template
  #   name: "Test example from ESPHome"
  #   id: btn_test_example
  #   on_press:
  #     - homeassistant.action:
  #         action: weather.get_forecasts
  #         data:
  #           entity_id: weather.hhut
  #           type: hourly
  #           return_response: true
  #         capture_response: true
  #         on_success:
  #           - lambda: |-
  #               if (!response.containsKey("response")) return;
  #               const auto &resp_obj = response["response"];
  #               if (!resp_obj.containsKey("weather.hhut")) return;
  #               const auto &entity = resp_obj["weather.hhut"];
  #               if (!entity.containsKey("forecast")) return;
  #               const auto &forecast = entity["forecast"];
  #               if (forecast.size() == 0) return;
  #               const auto &first_hour = forecast[0];
  #               float temperature = first_hour.containsKey("temperature") ? first_hour["temperature"].as<float>() : NAN;
  #               ESP_LOGI("weather", "Temperature next hour: %.1f", temperature);

  # - platform: template
  #   name: "Test Weather Forecast"
  #   id: btn_test_forecast
  #   on_press:
  #     - homeassistant.action:
  #         action: template.render
  #         data:
  #           template: "{{ state_attr('weather.hhut', 'forecast') | tojson }}"
  #         capture_response: true
  #         on_success:
  #           - lambda: |-
  #               if (!response.containsKey("result")) {
  #                 ESP_LOGW("weather", "No 'result' key in template response!");
  #                 return;
  #               }
  #               const auto &result = response["result"];
  #               std::string forecast_json = result.as<std::string>();
  #               ESP_LOGI("weather", "Forecast attribute JSON:\n%s", forecast_json.c_str());
  #         on_error:
  #           - lambda: |-
  #               ESP_LOGE("weather", "❌ Forecast fetch FAILED!");

wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}

# Default page selector (update options based on enabled features)

esphome:
  on_boot:
    - priority: 800  # Very early - before components load
      then:
        - delay: 50ms  # Brief delay for LVGL to initialize
        - lvgl.page.show: vertical_clock_page
        - logger.log: "Set initial page to Vertical Clock"
    - priority: -100
      then:
        - logger.log: "Boot sequence starting (priority -100)"
        # Note: RGB light turn-off removed to avoid package loading order issues
        # The startup_light_blink interval handles RGB light control
        - delay: 1s  # Brief delay for LVGL to initialize
        - lambda: |-
            const std::string &choice = id(default_page_select_boot).state;
            // Core pages
            if (choice == "Vertical Clock") {
              id(default_page_index) = 0;  // vertical_clock_page
            } else if (choice == "AirQ") {  // Comment out if AirQ disabled
              id(default_page_index) = 1;  // AirQ_page
            } else if (choice == "WiFi") {
              id(default_page_index) = 2;  // wifi_page
            // Weather page mappings (comment out if weather packages are disabled)
            } else if (choice == "Weather") {
              id(default_page_index) = 3;  // weather_forecast_page
            } else if (choice == "Daily Forecast") {
              id(default_page_index) = 4;  // daily_forecast_page
            } else if (choice == "Hourly Forecast") {
              id(default_page_index) = 5;  // hourly_forecast_page
            } else {
              id(default_page_index) = 0;  // Default to vertical clock if unknown
            }
        - logger.log:
            format: "Setting default page (index: %d)"
            args: ['id(default_page_index)']
        # Note: Boot sequence only handles Vertical Clock in Core
        # Device files should override on_boot to handle their specific pages
        - logger.log: "Boot: Showing Vertical Clock page (Core default)"
        - lvgl.page.show: vertical_clock_page
        - logger.log: "Boot sequence complete"

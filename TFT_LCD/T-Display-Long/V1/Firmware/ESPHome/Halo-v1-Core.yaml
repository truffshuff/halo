# ============================================================================
# HALO v1 - Core ESPHome Configuration
# ============================================================================
# ESP32-S3 Air Quality Monitor with LVGL Display
#
# Hardware: LilyGo T-Display-Long (ESP32-S3, 180x640 AMOLED display)
# Features: Air quality monitoring, weather display, WiFi stats, WireGuard VPN
# Dependencies: Requires device-specific file (e.g., halo-v1-79e384.yaml)
#              Requires secrets file with WiFi, HA, and WireGuard credentials
#
# Version: 25.11.15.1653
# Last Updated: November 15, 2025
# ============================================================================

substitutions:
  name: halo
  version: "25.11.15.1653"
  device_description: ${name} - v${version}.
  
# ============================================================================
# MODULAR ARCHITECTURE (Phases 1-2 Complete)
# ============================================================================
# Most components have been extracted to capability modules in packages/.
# This Core file contains cross-capability components and LVGL display config.
# See MODULARIZATION_PLAN_V2.md for details.
# ============================================================================

# Note: All switches moved to capability modules (see packages/features/)

select:
  - platform: template
    name: LED Effect
    id: led_effect_select
    entity_category: "Config"
    options:
      - "None"
      - "Rainbow Effect With Custom Values"
      - "Addressable Rainbow"
      - "Color Wipe"
      - "Scan"
      - "Twinkle"
      - "Fireworks"
      - "Strobe"
      - "Random Twinkle"
      - "Pink Lightning"
      - "AQI Color"
      - "Weather Condition"
      - "Auto Context"
      # Note: "AQI Color" requires airq-core.yaml to be enabled. When disabled (airq-stubs), selecting it safely turns light off
      # Note: "Weather Condition" and "Auto Context" require weather-core.yaml to be enabled. When disabled, selecting them safely turns light off
    initial_option: "None"
    restore_value: true
    optimistic: true
    on_value:
      - lambda: |-
          // Don't apply effects during boot - let startup_light_blink handle it
          if (!id(boot_complete)) return;

          std::string effect = id(led_effect_select).state;
          if (effect == "None") {
            auto call = id(rgb_light).turn_off();
            call.perform();
          } else if (effect == "AQI Color") {
            float aqi = id(computed_halo_aqi).state;
            if (std::isnan(aqi) || aqi <= 50) {
              auto call = id(rgb_light).turn_off();
              call.perform();
            } else {
              Color color;
              if (aqi <= 100) color = Color(255, 255, 0); // yellow
              else if (aqi <= 150) color = Color(255, 165, 0); // orange
              else if (aqi <= 200) color = Color(255, 0, 0); // red
              else if (aqi <= 300) color = Color(128, 0, 128); // purple
              else color = Color(128, 0, 0); // maroon
              auto call = id(rgb_light).turn_on();
              call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
              call.perform();
            }
          } else if (effect == "Weather Condition" || effect == "Auto Context") {
            // Lambda-based effects - activate them
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          } else {
            // Standard effects
            auto call = id(rgb_light).turn_on();
            call.set_effect(effect);
            call.perform();
          }

interval:

  # Batched sensor UI update - prevents LVGL cascade rendering
  # NOTE: This is legacy code - sensor_ui_dirty is never set in current config
  # Kept for potential future use
  - interval: 2s
    then:
      - lambda: |-
          // Only update if sensors changed since last batch
          if (id(sensor_ui_dirty)) {
          const uint32_t now = millis();
          // Ensure minimum 2s between UI refreshes
          if ((now - id(last_sensor_ui_update)) >= 2000) {
            ESP_LOGD("sensor_batch", "Batched sensor UI update triggered");
            id(sensor_ui_dirty) = false;
            id(last_sensor_ui_update) = now;
            // Watchdog timer updated by actual LVGL rendering, not here
          }
          }

  # Display watchdog and periodic health check intervals moved to features/diagnostics/diagnostics.yaml (Phase 2)

  # Automatic page rotation - controllable via Home Assistant with custom page selection and order
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
                if (!id(boot_complete)) return false;
                // Only rotate if auto rotation is enabled
                if (!id(auto_page_rotation_enabled)) return false;

                const uint32_t now = millis();
                const uint32_t interval_ms = id(auto_page_rotation_interval) * 1000;

                // Check if enough time has passed since last rotation
                if ((now - id(last_auto_rotation_time)) < interval_ms) return false;

                // Build separate parallel arrays for page info
                std::vector<int> page_orders;
                std::vector<std::string> page_ids;  // Maps to the page ID in sorted order

                // Collect enabled pages with their orders (use string ID to identify page)
                // Page IDs: vertical_clock, airq, wifi, weather, hourly_forecast, daily_forecast

                // Core pages
                if (id(page_rotation_vertical_clock_enabled)) {
                page_orders.push_back(id(page_rotation_vertical_clock_order));
                page_ids.push_back("vertical_clock");
                }
                // AirQ page (conditionally available based on AirQ package)
                // This global is provided by either airq-core.yaml or airq-stubs.yaml
                if (id(page_rotation_AirQ_enabled)) {
                page_orders.push_back(id(page_rotation_AirQ_order));
                page_ids.push_back("airq");
                }
                // WiFi page (conditionally available based on WiFi package)
                // This global is provided by either wifi-core.yaml or wifi-stubs.yaml
                if (id(page_rotation_wifi_enabled)) {
                page_orders.push_back(id(page_rotation_wifi_order));
                page_ids.push_back("wifi");
                }

                // Weather pages (conditionally available based on weather package)
                // These globals are provided by either weather-core.yaml or weather-stubs.yaml
                if (id(page_rotation_weather_enabled)) {
                page_orders.push_back(id(page_rotation_weather_order));
                page_ids.push_back("weather");
                }
                if (id(page_rotation_hourly_forecast_enabled)) {
                page_orders.push_back(id(page_rotation_hourly_forecast_order));
                page_ids.push_back("hourly_forecast");
                }
                // Compact hourly summary page
                if (id(page_rotation_hourly_summary_enabled)) {
                page_orders.push_back(id(page_rotation_hourly_summary_order));
                page_ids.push_back("hourly_summary_1");
                }
                if (id(page_rotation_daily_forecast_enabled)) {
                page_orders.push_back(id(page_rotation_daily_forecast_order));
                page_ids.push_back("daily_forecast");
                }

                // If no pages are enabled, don't rotate
                if (page_orders.empty()) {
                ESP_LOGW("page_rotation", "No pages enabled for rotation");
                return false;
                }

                // Sort IDs based on their order numbers (bubble sort for simplicity)
                for (size_t i = 0; i < page_orders.size(); i++) {
                for (size_t j = i + 1; j < page_orders.size(); j++) {
                  if (page_orders[j] < page_orders[i]) {
                    std::swap(page_orders[i], page_orders[j]);
                    std::swap(page_ids[i], page_ids[j]);
                  }
                }
                }

                // Use a static variable to track position in rotation sequence
                static int rotation_position = 0;

                // Make sure rotation_position is within bounds
                if (rotation_position >= page_ids.size()) {
                rotation_position = 0;
                }

                // Get the next page to show
                std::string next_page_id = page_ids[rotation_position];

                // Store the next page ID in current_page_name for the action to use
                id(current_page_name) = next_page_id;

                // Advance rotation position for next time (wrap around)
                rotation_position = (rotation_position + 1) % page_ids.size();

                // Show the next page
                ESP_LOGD("page_rotation", "Rotating to page '%s' (order: %d)",
                       next_page_id.c_str(), page_orders[rotation_position > 0 ? rotation_position - 1 : page_orders.size() - 1]);

                id(last_auto_rotation_time) = now;
                return true;
          then:
            # Note: Core no longer shows pages - device files must handle this
            # The rotation logic above sets current_page_name, but device files
            # must implement their own interval to actually show the pages
            - logger.log:
                format: "Core: Rotation scheduled to page '%s'"
                args: ['id(current_page_name).c_str()']
                level: DEBUG

  # Note: Colon blink interval moved to features/clock/clock_base.yaml (Phase 2)
  # Note: Weather refresh intervals moved to features/weather/weather_base.yaml (Phase 2)

  - interval: 100ms  # Check frequently for page index changes
    then:
      - if:
          condition:
            lambda: |-
                static std::string last_displayed_page = "";

                // Don't do anything until boot is complete
                if (!id(boot_complete)) return false;

                // Check if page ID has changed
                std::string current = id(current_page_name);
                if (current == last_displayed_page) return false;

                // Page ID changed
                last_displayed_page = current;
                ESP_LOGD("page_rotation", "Page changed to '%s'", current.c_str());
                return true;
          then:
            # Vertical Clock
            - if:
                condition:
                  lambda: 'return id(current_page_name) == "vertical_clock";'
                then:
                  - logger.log: "Page rotation: Showing Vertical Clock"
                  - lvgl.page.show:
                      id: vertical_clock_page
                      animation: OUT_LEFT
                      time: 300ms
                else:
                  # AirQ
                  - if:
                      condition:
                        lambda: 'return id(current_page_name) == "airq";'
                      then:
                        - logger.log: "Page rotation: Showing AirQ page"
                        - lvgl.page.show:
                            id: AirQ_page
                            animation: OUT_LEFT
                            time: 300ms
                      else:
                        # WiFi
                        - if:
                            condition:
                              lambda: 'return id(current_page_name) == "wifi";'
                            then:
                              - logger.log: "Page rotation: Showing WiFi page"
                              - lvgl.page.show:
                                  id: wifi_page
                                  animation: OUT_LEFT
                                  time: 300ms
                            else:
                              # Weather
                              - if:
                                  condition:
                                    lambda: 'return id(current_page_name) == "weather";'
                                  then:
                                    - logger.log: "Page rotation: Showing Weather page"
                                    - lvgl.page.show:
                                        id: weather_forecast_page
                                        animation: OUT_LEFT
                                        time: 300ms
                                  else:
                                    # Hourly Summary Page 1
                                    - if:
                                        condition:
                                          lambda: 'return id(current_page_name) == "hourly_summary_1";'
                                        then:
                                          - logger.log: "Page rotation: Showing Hourly Summary Page 1"
                                          - lvgl.page.show:
                                              id: hourly_summary_page_1
                                              animation: OUT_LEFT
                                              time: 300ms
                                        else:
                                          # Hourly Summary Page 2
                                          - if:
                                              condition:
                                                lambda: 'return id(current_page_name) == "hourly_summary_2";'
                                              then:
                                                - logger.log: "Page rotation: Showing Hourly Summary Page 2"
                                                - lvgl.page.show:
                                                    id: hourly_summary_page_2
                                                    animation: OUT_LEFT
                                                    time: 300ms
                                              else:
                                                # Daily Forecast
                                                - if:
                                                    condition:
                                                      lambda: 'return id(current_page_name) == "daily_forecast";'
                                                    then:
                                                      - logger.log: "Page rotation: Showing Daily Forecast page"
                                                      - lvgl.page.show:
                                                          id: daily_forecast_page
                                                          animation: OUT_LEFT
                                                          time: 300ms
                                                    else:
                                                      # Hourly Forecast (8 pages)
                                                      - if:
                                                          condition:
                                                            lambda: 'return id(current_page_name) == "hourly_forecast";'
                                                          then:
                                                            - logger.log: "Page rotation: Showing Hourly Forecast Page 1"
                                                            - lvgl.page.show:
                                                                id: hourly_forecast_page
                                                                animation: OUT_LEFT
                                                                time: 300ms
                                                          else:
                                                            # Unknown page - fall back to vertical clock
                                                            - logger.log:
                                                                format: "Page rotation: Page '%s' not available, falling back to Vertical Clock"
                                                                args: ['id(current_page_name).c_str()']
                                                                level: WARN
                                                            - lvgl.page.show:
                                                                id: vertical_clock_page
                                                                animation: OUT_LEFT
                                                                time: 300ms


  - interval: 1s  # Reduced from 5s for faster WiFi stats updates
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete);'
          then:
            - if:
                condition:
                  wifi.connected:
                then:
                  - lambda: |-
                      char buffer[32];
                      snprintf(buffer, sizeof(buffer), "Signal: %.0f dBm", id(wifi_signal_db).state);
                      std::string new_text(buffer);
                      if (new_text != id(wifi_signal_last_text)) {
                      id(wifi_signal_last_text) = new_text;
                      id(wifi_signal_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wifi_signal_label
                            text: !lambda 'return id(wifi_signal_last_text);'
                        - lambda: 'id(wifi_signal_needs_render) = false;'
                  # Update WiFi signal bar
                  - lambda: |-
                      float signal = id(wifi_signal_db).state;
                      if (std::isnan(signal)) {
                      signal = -200.0f;
                      }
                      if (signal != id(wifi_signal_bar_last_value)) {
                      id(wifi_signal_bar_last_value) = signal;
                      id(wifi_signal_bar_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(current_page_name) == "wifi";'
                      then:
                        - lvgl.bar.update:
                            id: wifi_signal_bar
                            value: !lambda 'return id(wifi_signal_bar_last_value);'
                        - lambda: 'id(wifi_signal_bar_needs_render) = false;'
                  # Update WiFi SSID
                  - lambda: |-
                      std::string ssid = esphome::wifi::global_wifi_component->wifi_ssid();
                      std::string new_text = std::string("SSID: ") + ssid;
                      if (new_text != id(wifi_ssid_last_text)) {
                      id(wifi_ssid_last_text) = new_text;
                      id(wifi_ssid_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wifi_ssid_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wifi_ssid_label
                            text: !lambda 'return id(wifi_ssid_last_text);'
                        - lambda: 'id(wifi_ssid_needs_render) = false;'
                  # Update WiFi IP address
                  - lambda: |-
                      auto addresses = esphome::wifi::global_wifi_component->get_ip_addresses();
                      std::string ip_text = "IP: Not assigned";
                      if (!addresses.empty()) {
                      ip_text = std::string("IP: ") + addresses[0].str();
                      }
                      if (ip_text != id(wifi_ip_last_text)) {
                      id(wifi_ip_last_text) = ip_text;
                      id(wifi_ip_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wifi_ip_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wifi_ip_label
                            text: !lambda 'return id(wifi_ip_last_text);'
                        - lambda: 'id(wifi_ip_needs_render) = false;'
                  # Update Home Assistant connection status icon
                  - lambda: |-
                      bool ha_connected = id(ink_ha_connected).state;
                      if (ha_connected != id(ha_status_last_state)) {
                      id(ha_status_last_state) = ha_connected;
                      id(ha_status_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(ha_status_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.widget.update:
                            id: ha_status_icon
                            text_color: !lambda 'return id(ink_ha_connected).state ? id(my_green) : id(my_gray);'
                        - lambda: 'id(ha_status_needs_render) = false;'
                else:
                  # WiFi disconnected - hide WiFi logo on AirQ page (only if AirQ page exists)
                  # This is guarded to avoid errors in wifi-only mode
                  # - if:
                  #     condition:
                  #       lambda: 'return id(wifi_logo_visible) && id(current_page_name) == "airq";'
                  #     then:
                  #       - lvgl.widget.hide:
                  #           id: ym_image
                  # - if:
                  #     condition:
                  #       lambda: 'return id(wifi_logo_visible);'
                  #     then:
                  #       - lambda: 'id(wifi_logo_visible) = false;'
                  # Update disconnected signal text
                  - lambda: |-
                      const std::string new_text = "Signal: --";
                      if (new_text != id(wifi_signal_last_text)) {
                      id(wifi_signal_last_text) = new_text;
                      id(wifi_signal_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wifi_signal_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wifi_signal_label
                            text: !lambda 'return id(wifi_signal_last_text);'
                        - lambda: 'id(wifi_signal_needs_render) = false;'
                  # Update disconnected signal bar
                  - lambda: |-
                      float new_value = -200.0f;
                      if (new_value != id(wifi_signal_bar_last_value)) {
                      id(wifi_signal_bar_last_value) = new_value;
                      id(wifi_signal_bar_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wifi_signal_bar_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.bar.update:
                            id: wifi_signal_bar
                            value: !lambda 'return id(wifi_signal_bar_last_value);'
                        - lambda: 'id(wifi_signal_bar_needs_render) = false;'
                  # Update disconnected SSID
                  - lambda: |-
                      const std::string ssid_text = "SSID: Not connected";
                      if (ssid_text != id(wifi_ssid_last_text)) {
                      id(wifi_ssid_last_text) = ssid_text;
                      id(wifi_ssid_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wifi_ssid_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wifi_ssid_label
                            text: !lambda 'return id(wifi_ssid_last_text);'
                        - lambda: 'id(wifi_ssid_needs_render) = false;'
                  # Update disconnected IP
                  - lambda: |-
                      const std::string ip_text = "IP: Not connected";
                      if (ip_text != id(wifi_ip_last_text)) {
                      id(wifi_ip_last_text) = ip_text;
                      id(wifi_ip_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wifi_ip_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wifi_ip_label
                            text: !lambda 'return id(wifi_ip_last_text);'
                        - lambda: 'id(wifi_ip_needs_render) = false;'
                  # WireGuard display updates (wg_address_label, wg_handshake_label, wg_status_label)
                  # are now handled by on_value callbacks in packages/features/wireguard/wireguard.yaml
                  # The interval below just renders them when on the wifi page
                  - if:
                      condition:
                        lambda: 'return id(wg_status_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wg_status_label
                            text: !lambda 'return id(wg_status_last_text);'
                        - lambda: 'id(wg_status_needs_render) = false;'
                  - if:
                      condition:
                        lambda: 'return id(wg_address_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wg_address_label
                            text: !lambda 'return id(wg_address_last_text);'
                        - lambda: 'id(wg_address_needs_render) = false;'
                  - if:
                      condition:
                        lambda: 'return id(wg_handshake_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wg_handshake_label
                            text: !lambda 'return id(wg_handshake_last_text);'
                        - lambda: 'id(wg_handshake_needs_render) = false;'
                  - if:
                      condition:
                        lambda: 'return id(wg_endpoint_needs_render) && id(current_page_name) == "wifi";'
                      then:
                        - lvgl.label.update:
                            id: wg_endpoint_label
                            text: !lambda 'return id(wg_endpoint_last_text);'
                        - lambda: 'id(wg_endpoint_needs_render) = false;'

  # Optional: API watchdog for automatic recovery
  # Monitors Home Assistant API connection and reboots if disconnected for 30+ minutes
  # This provides automatic recovery from API failures while still allowing HA restarts
  - interval: 5min
    then:
      - if:
          condition:
            lambda: |-
                static uint32_t last_connected = millis();
                if (id(ink_ha_connected).state) {
                last_connected = millis();
                return false;
                }
                return (millis() - last_connected) > 1800000; // 30 min
          then:
            - logger.log: "API disconnected for 30+ minutes, triggering automatic reboot..."
            - button.press: esp_reboot_button  # Trigger ESP restart

# ============================================================================
# Home Assistant API Configuration
# ============================================================================
# Handles communication with Home Assistant for sensors, switches, and services
#
# reboot_timeout: 0s - CRITICAL SETTING
#   Disables automatic device reboot when HA connection is lost
#   WHY: During HA restarts or network issues, device should keep running
#        and attempt reconnection rather than rebooting repeatedly
#   RISK: If API breaks, device won't auto-recover without manual intervention
# ============================================================================
api:
  reboot_timeout: ${api_reboot_timeout}  # Set to 0s to disable auto-reboot on API disconnect
  listen_backlog: 8
  max_connections: 16
  max_send_queue: 64  # Increased to handle BLE advertisement bursts
  # Optimized settings for improved switch responsiveness and connection stability
  # These reduce latency and ensure faster state updates between device and Home Assistant
  on_client_connected:
      - delay: 1s  # Brief delay for API stabilization
      - lambda: 'id(cycleCounter) = 30;'  # Stop startup rainbow animation
      - lambda: 'id(boot_complete) = true;'  # Enable normal operation

      # ========================================================================
      # Restore User LED Effect Selection
      # ========================================================================
      # WHY: During boot, startup_light_blink takes control of RGB light
      #      When HA connects, we restore user's saved effect preference
      # DELAY: 2s ensures rainbow effect fully stops before applying new effect
      # ========================================================================
      - delay: 2s
      - lambda: |-
          std::string effect = id(led_effect_select).state;
          if (effect == "None") {
          auto call = id(rgb_light).turn_off();
          call.perform();
          } else if (effect == "AQI Color") {
          float aqi = id(computed_halo_aqi).state;
          if (std::isnan(aqi) || aqi <= 50) {
            auto call = id(rgb_light).turn_off();
            call.perform();
          } else {
            Color color;
            if (aqi <= 100) color = Color(255, 255, 0);
            else if (aqi <= 150) color = Color(255, 165, 0);
            else if (aqi <= 200) color = Color(255, 0, 0);
            else if (aqi <= 300) color = Color(128, 0, 128);
            else color = Color(128, 0, 0);
            auto call = id(rgb_light).turn_on();
            call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
            call.perform();
          }
          } else if (effect == "Weather Condition" || effect == "Auto Context") {
          // New lambda effects - activate them
          auto call = id(rgb_light).turn_on();
          call.set_effect(effect);
          call.perform();
          } else {
          auto call = id(rgb_light).turn_on();
          call.set_effect(effect);
          call.perform();
          }
      # BLE scanning disabled (using NimBLE instead of Bluedroid)
      # - delay: 500ms
      # - esp32_ble_tracker.start_scan:
      #     continuous: true
  # ============================================================================
  # Custom Services (callable from Home Assistant)
  # ============================================================================

  on_client_disconnected:
    # BLE scanning disabled (using NimBLE instead of Bluedroid)
    # - esp32_ble_tracker.stop_scan:
    then:
      - logger.log: "Home Assistant disconnected"
  
  services:

# Note: Scripts, numbers, and most sensors moved to capability modules (see packages/features/)

# Note: Sensors moved to capability modules (see packages/features/)

lvgl:
  id: lvgl_main
  displays:
    - lily_display
  touchscreens:
    - lily_touch
  buffer_size: 30%  # Optimized for memory: 30% buffer (~69KB for 180x640@16bit)
                    # With CONFIG_SPIRAM_USE_MALLOC=y, large allocations use PSRAM automatically
                    # Trade-off: minimal tearing, stable operation with better free heap
  byte_order: big_endian
  color_depth: 16
  
  disp_bg_color: 0x000000
  disp_bg_opa: COVER
  disp_bg_image: none
  log_level: WARN  # Reduce logging overhead

  # Gradient definitions used by WiFi pages
  gradients:
    - id: wifi_signal_gradient
      direction: hor
      dither: none
      stops:
        - color: 0xFF0000  # Red - weak signal
          position: 0
        - color: 0xFF8000  # Orange
          position: 64
        - color: 0xFFFF00  # Yellow
          position: 128
        - color: 0x80FF00  # Yellow-green
          position: 192
        - color: 0x00FF00  # Green - strong signal
          position: 255

  # IMPORTANT: Pages are now modularized into separate package files
  # Phase 1: Base components (globals, hardware) are in packages/base/
  # Phase 2: Simple pages (clock, airq, wifi) are in packages/pages/
  # Phase 3: Weather system (hourly/daily forecast, LED effects) are in packages/weather/

  # ============================================================================
  # LVGL Pages - Weather Pages
  # ============================================================================
  # HOURLY FORECAST PAGES: Moved to packages/weather/hourly-forecast-pages.yaml (Phase 3)
  # DAILY FORECAST PAGES: Moved to packages/weather/daily-forecast-pages.yaml (Phase 3)
  pages:
      
# ============================================================================
# BUTTON SECTION MOVED TO packages/features/diagnostics/diagnostics.yaml
# ============================================================================
# All diagnostic buttons have been extracted to the diagnostics module:
# - ESP Reboot
# - Factory Reset ESP
# - Clear Improv WiFi Credentials
# - Recover Display (Hard Reset)
# ============================================================================

# ============================================================================
# WiFi Configuration
# ============================================================================
# CREDENTIALS: Define in device-specific file (e.g., halo-v1-79e384.yaml)
#   wifi_ssid: "YourNetworkName"
#   wifi_password: "YourNetworkPassword"
#
# SECURITY: WiFi credentials are stored in plaintext in compiled firmware
#           Use WPA2/WPA3 encryption on your access point
#           Consider using secrets file for sensitive deployments
# ============================================================================
wifi:
  ssid: ${wifi_ssid}
  password: ${wifi_password}

  # Reset startup light blink when WiFi disconnects
  # This allows the rainbow effect to restart when connection is lost
  on_disconnect:
    - lambda: |-
        id(cycleCounter) = 0;
        ESP_LOGI("wifi", "WiFi disconnected - resetting startup blink counter");

  # Ensure startup blink stops when WiFi reconnects
  on_connect:
    - lambda: |-
        if (id(cycleCounter) < 30) {
        id(cycleCounter) = 30;
        ESP_LOGI("wifi", "WiFi connected - stopping startup blink");
        }

# ============================================================================
# WireGuard VPN Configuration
# ============================================================================
# Provides encrypted tunnel to home network when away from home WiFi
#
# CREDENTIALS: Stored in secrets.yaml (never commit to git!)
#   wg_address: VPN IP address (e.g., 10.6.0.3)
#   wg_netmask: VPN subnet mask - NOTE: In WireGuard, netmask behavior is inverse!
#               - 0.0.0.0 = ALL traffic routes through VPN tunnel (full tunnel)
#               - 255.255.255.0 = Only VPN subnet traffic routes through tunnel (split tunnel)
#               Default: 0.0.0.0 to ensure all traffic is encrypted when VPN is active
#   wg_prikey: Device private key (generate with: wg genkey)
#   wg_peerport: VPN server port (typically 51820)
#   wg_peerendpt: VPN server hostname or IP
#   wg_pubkey: VPN server public key
#   wg_shrdkey: Pre-shared key for additional security (optional)
#
# ALLOWED IPs: Traffic destined for these networks goes through VPN tunnel
#   192.168.1.0/24: Home LAN
#   10.6.0.1/32: VPN server gateway
#   10.6.0.2/32: Additional VPN peer (optional)
#
# KEEPALIVE: 25s - Maintains NAT mappings for reliable connection
# require_connection_to_proceed: false - Device boots even if VPN fails
# ============================================================================
# WireGuard configuration has been moved to packages/features/wireguard/wireguard.yaml

# ============================================================================
# ESPHome Boot Sequence Configuration
# ============================================================================
# ESPHOME BOOT PRIORITIES (higher numbers run first):
#   800-900: Very early init (before WiFi/components)
#   600-700: Component initialization
#   250:     WiFi connection
#   100:     Sensor setup
#   50:      Application logic
#   -100:    Late initialization (after everything loaded)
#
# Our boot stages:
#   1. Priority 800: Show initial page before components load
#   2. Priority 50: Enable WireGuard after BLE stabilizes (20s delay)
#   3. Priority -100: Set default page and complete boot
# ============================================================================

# ============================================================================
# NIMBLE BLUETOOTH PROXY
# ============================================================================
# Custom NimBLE-based Bluetooth proxy for Home Assistant
# Uses NimBLE stack instead of Bluedroid for better performance and lower RAM
# 
# Benefits:
# - ~55KB RAM savings vs Bluedroid
# - Better WiFi coexistence
# - Lower power consumption
# - Faster connection handling
# ============================================================================

# Stub bluetooth_proxy component (NOT the native ESPHome one)
# This ONLY provides header files and USE_BLUETOOTH_PROXY define for API types
# It contains NO Bluedroid code - just enables the protobuf message types

# ESP32 Improv Configuration (Optional)
# Allows WiFi provisioning via BLE using the Improv standard
# Useful for initial device setup without hardcoded credentials
# DISABLED: Requires BLE tracker
# esp32_improv:
#   authorizer: none

# API Integration - Dynamic BLE Scanning
# Automatically start/stop BLE scanning based on Home Assistant connection
# This saves power and reduces heap usage when HA is disconnected

esphome:
  name: ${name}

  # ============================================================================
  # C++ Helper Functions - Reusable Code to Reduce Duplication
  # ============================================================================
  # weather_helpers component (declared at line 860) provides reusable formatting
  # functions to eliminate code duplication in weather forecast display scripts.
  # Functions automatically available via external_components system.
  # ============================================================================

  libraries:
    # No additional libraries needed - using standard C++ and ESP-IDF

  on_boot:
    # -------------------------------------------------------------------------
    # Boot Stage 1: Early Display Initialization (Priority 800)
    # -------------------------------------------------------------------------
    # Runs before WiFi and sensors to show something on screen immediately
    # 50ms delay allows LVGL to complete basic initialization
    # Note: Watchdog timer initialization moved to features/diagnostics/diagnostics.yaml (Phase 2)
    - priority: 800
      then:
        - delay: 50ms
        - lvgl.page.show: vertical_clock_page
        - logger.log: "Set initial page to Vertical Clock"

    # -------------------------------------------------------------------------
    # Boot Stage 2: WireGuard Delayed Start (Priority 50)
    # -------------------------------------------------------------------------
    # WireGuard boot hook has been moved to packages/features/wireguard/wireguard.yaml

    # -------------------------------------------------------------------------
    # Boot Stage 3: Default Page Selection (Priority -100)
    # -------------------------------------------------------------------------
    # Runs last after all components initialized
    # Reads user's default page preference and navigates to it
    # Note: RGB light control is handled by startup_light_blink interval
    - priority: -100
      then:
        - logger.log: "Boot sequence starting (priority -100)"
        - delay: 1s  # Brief delay for LVGL page system to be ready

        # Map user's text selection to page index number
        - lambda: |-
            const std::string &choice = id(default_page_select_boot).state;
            // Core pages
            if (choice == "Vertical Clock") {
            id(default_page_index) = 0;  // vertical_clock_page
            } else if (choice == "AirQ") {  // Comment out if AirQ disabled
            id(default_page_index) = 1;  // AirQ_page
            } else if (choice == "WiFi") {
            id(default_page_index) = 2;  // wifi_page
            // Weather page mappings (comment out if weather packages are disabled)
            } else if (choice == "Weather") {
            id(default_page_index) = 3;  // weather_forecast_page
            } else if (choice == "Daily Forecast") {
            id(default_page_index) = 4;  // daily_forecast_page
            } else if (choice == "Hourly Forecast") {
            id(default_page_index) = 5;  // hourly_forecast_page
            } else {
            id(default_page_index) = 0;  // Default to vertical clock if unknown
            }
        - logger.log:
            format: "Setting default page (index: %d)"
            args: ['id(default_page_index)']
        # Note: Boot sequence only handles Vertical Clock in Core
        # Device files should override on_boot to handle their specific pages
        - logger.log: "Boot: Showing Vertical Clock page (Core default)"
        - lvgl.page.show: vertical_clock_page
        - logger.log: "Boot sequence complete"

# WireGuard Display Package
# Include this package along with wireguard.yaml to add WireGuard display/UI support
#
# Usage:
#   packages:
#     wireguard: !include packages/wireguard.yaml
#     wireguard_display: !include packages/wireguard-display.yaml
#
# This package provides:
#   - Global variables for tracking WireGuard display state
#   - Optimized rendering flags to reduce unnecessary UI updates
#   - Interval-based updates for WireGuard status display
#
# Note: This is intended for devices with displays (e.g., LVGL-based interfaces)
#
# Required LVGL widget IDs in your display configuration:
#   - wg_status_label: Status text label
#   - wg_address_label: VPN IP address label
#   - wg_endpoint_label: Endpoint label
#   - wg_handshake_label: Handshake time label
#
# Required global variables in your main config:
#   - boot_complete: bool to track if boot is complete
#   - current_page_index: int for current page (assumes wifi_page is index 2)
#
# Required color IDs in your display configuration:
#   - my_green: Color for connected state
#   - my_gray: Color for disconnected state
#
# Required time component:
#   - sntp_time: SNTP time component for handshake time calculation

# Global variables for WireGuard display state tracking
globals:
  - id: wg_status_last_text
    type: std::string
    restore_value: no
    initial_value: ""
  - id: wg_status_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: wg_status_connected_state
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: wg_status_color_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: wg_address_last_text
    type: std::string
    restore_value: no
    initial_value: ""
  - id: wg_address_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: wg_handshake_last_text
    type: std::string
    restore_value: no
    initial_value: ""
  - id: wg_handshake_needs_render
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: wg_endpoint_initialized
    type: bool
    restore_value: no
    initial_value: 'false'

# Interval for updating WireGuard display elements
# This runs every 5 seconds to update WireGuard status, address, and handshake information
# Only updates when WiFi is connected and boot is complete
interval:
  - interval: 5s
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete);'
          then:
            - if:
                condition:
                  wifi.connected:
                then:
                  # Update WireGuard status text and state
                  - lambda: |-
                      bool wg_connected = id(wireguard_status).state;
                      std::string new_text = wg_connected ? "Status: \nConnected" : "Status: \nDisconnected";
                      if (new_text != id(wg_status_last_text)) {
                        id(wg_status_last_text) = new_text;
                        id(wg_status_needs_render) = true;
                      }
                      if (wg_connected != id(wg_status_connected_state)) {
                        id(wg_status_connected_state) = wg_connected;
                        id(wg_status_color_needs_render) = true;
                      }
                  # Render WireGuard status text if needed
                  - if:
                      condition:
                        lambda: 'return id(wg_status_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_status_label
                            text: !lambda 'return id(wg_status_last_text);'
                        - lambda: 'id(wg_status_needs_render) = false;'
                  # Update WireGuard status color if needed
                  - if:
                      condition:
                        lambda: 'return id(wg_status_color_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.widget.update:
                            id: wg_status_label
                            text_color: !lambda |-
                              if (id(wg_status_connected_state)) {
                                return id(my_green);
                              } else {
                                return id(my_gray);
                              }
                        - lambda: 'id(wg_status_color_needs_render) = false;'
                  # Update WireGuard address
                  - lambda: |-
                      std::string new_text = "VPN IP: Not configured";
                      if (id(wireguard_address_text).has_state()) {
                        new_text = std::string("VPN IP: ") + id(wireguard_address_text).state;
                      }
                      if (new_text != id(wg_address_last_text)) {
                        id(wg_address_last_text) = new_text;
                        id(wg_address_needs_render) = true;
                      }
                  # Render WireGuard address if needed
                  - if:
                      condition:
                        lambda: 'return id(wg_address_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_address_label
                            text: !lambda 'return id(wg_address_last_text);'
                        - lambda: 'id(wg_address_needs_render) = false;'
                  # Initialize WireGuard endpoint label once
                  - if:
                      condition:
                        lambda: 'return !id(wg_endpoint_initialized) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_endpoint_label
                            text: "Endpoint: \nConfigured"
                        - lambda: 'id(wg_endpoint_initialized) = true;'
                  # Update WireGuard handshake time
                  - lambda: |-
                      std::string handshake_text;
                      if (!std::isnan(id(wireguard_handshake).state)) {
                        const auto current_time = id(sntp_time).now();
                        if (current_time.is_valid()) {
                          int seconds_ago = current_time.timestamp - static_cast<int>(id(wireguard_handshake).state);
                          auto handshake_time = ESPTime::from_epoch_local(static_cast<int>(id(wireguard_handshake).state));
                          char time_ago[32];
                          if (seconds_ago < 0) {
                            snprintf(time_ago, sizeof(time_ago), "%ds", static_cast<int>(id(wireguard_handshake).state));
                          } else if (seconds_ago < 60) {
                            snprintf(time_ago, sizeof(time_ago), "%ds ago", seconds_ago);
                          } else if (seconds_ago < 3600) {
                            snprintf(time_ago, sizeof(time_ago), "%dm ago", seconds_ago / 60);
                          } else if (seconds_ago < 86400) {
                            snprintf(time_ago, sizeof(time_ago), "%dh ago", seconds_ago / 3600);
                          } else {
                            snprintf(time_ago, sizeof(time_ago), "%dd ago", seconds_ago / 86400);
                          }
                          char buffer[128];
                          snprintf(buffer, sizeof(buffer), "Handshake: \n%s @\n\n%02d:%02d:%02d",
                                   time_ago, handshake_time.hour, handshake_time.minute, handshake_time.second);
                          handshake_text = buffer;
                        } else {
                          handshake_text = "Handshake: \nUnknown";
                        }
                      } else {
                        handshake_text = "Handshake: \nNever";
                      }
                      if (handshake_text != id(wg_handshake_last_text)) {
                        id(wg_handshake_last_text) = handshake_text;
                        id(wg_handshake_needs_render) = true;
                      }
                  # Render WireGuard handshake if needed
                  - if:
                      condition:
                        lambda: 'return id(wg_handshake_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_handshake_label
                            text: !lambda 'return id(wg_handshake_last_text);'
                        - lambda: 'id(wg_handshake_needs_render) = false;'
                else:
                  # WiFi disconnected - show disconnected state for WireGuard
                  - lambda: |-
                      const bool wg_connected = false;
                      const std::string status_text = "Status: \nDisconnected";
                      if (status_text != id(wg_status_last_text)) {
                        id(wg_status_last_text) = status_text;
                        id(wg_status_needs_render) = true;
                      }
                      if (wg_connected != id(wg_status_connected_state)) {
                        id(wg_status_connected_state) = wg_connected;
                        id(wg_status_color_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wg_status_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_status_label
                            text: !lambda 'return id(wg_status_last_text);'
                        - lambda: 'id(wg_status_needs_render) = false;'
                  - if:
                      condition:
                        lambda: 'return id(wg_status_color_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.widget.update:
                            id: wg_status_label
                            text_color: !lambda 'return id(my_gray);'
                        - lambda: 'id(wg_status_color_needs_render) = false;'
                  - lambda: |-
                      const std::string address_text = "VPN IP: Not configured";
                      if (address_text != id(wg_address_last_text)) {
                        id(wg_address_last_text) = address_text;
                        id(wg_address_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wg_address_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_address_label
                            text: !lambda 'return id(wg_address_last_text);'
                        - lambda: 'id(wg_address_needs_render) = false;'
                  - lambda: |-
                      const std::string handshake_text = "Handshake: \nUnavailable";
                      if (handshake_text != id(wg_handshake_last_text)) {
                        id(wg_handshake_last_text) = handshake_text;
                        id(wg_handshake_needs_render) = true;
                      }
                  - if:
                      condition:
                        lambda: 'return id(wg_handshake_needs_render) && id(current_page_index) == 2;'  # wifi_page
                      then:
                        - lvgl.label.update:
                            id: wg_handshake_label
                            text: !lambda 'return id(wg_handshake_last_text);'
                        - lambda: 'id(wg_handshake_needs_render) = false;'

# ============================================================================
# Diagnostics & System Health Monitoring Capability Module
# ============================================================================
# Provides comprehensive system diagnostics and health monitoring
#
# FEATURES:
#   - Memory monitoring (heap, PSRAM, DMA, fragmentation)
#   - Display health monitoring and automatic recovery
#   - System status (uptime, WiFi signal, online status)
#   - Performance metrics (display refresh rate, update duration)
#   - System control (restart, factory reset, WiFi credential clearing)
#   - Automatic display watchdog (black screen recovery)
#   - Periodic display controller health checks
#
# HARDWARE REQUIRED:
#   - ESP32-S3 with PSRAM (built-in)
#   - AXS15231 display controller
#   - WiFi (built-in)
#
# DEPENDENCIES:
#   - system/esphome_core.yaml (ESP32 config)
#   - system/display_hardware.yaml (Display controller, backlight)
#   - system/networking.yaml (WiFi for online status)
#
# MEMORY USAGE: ~5KB
#
# WATCHDOG FEATURES:
#   - Automatic black screen recovery (checks every 30s)
#   - Triggers if no display updates for 60s
#   - Periodic health check every 5 minutes
#   - Recovery counter tracking
#   - Manual recovery button for immediate reset
#
# Created: 2025-11-14 (Phase 2 extraction)
# ============================================================================

# ============================================================================
# Globals (Diagnostics-specific)
# ============================================================================
globals:
  # Display watchdog - tracks last LVGL update to detect black screen
  - id: last_display_update_time
    type: uint32_t
    restore_value: no
    initial_value: '0'

  # Display watchdog enabled flag
  - id: display_watchdog_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'

  # Boot completion flag (used to prevent watchdog during boot)
  - id: boot_complete
    type: bool
    restore_value: no
    initial_value: 'false'

# ============================================================================
# Binary Sensor Components
# ============================================================================
binary_sensor:
  # Online status - indicates connection to Home Assistant
  - platform: status
    name: Online
    id: ink_ha_connected

  # Display backlight state indicator
  - platform: template
    name: "Display Backlight Active"
    id: display_backlight_state
    entity_category: "diagnostic"
    lambda: 'return id(display_backlight_is_on);'

# ============================================================================
# Sensor Components
# ============================================================================
sensor:
  # ============================================================================
  # System Status Sensors
  # ============================================================================

  # Device uptime in seconds
  - platform: uptime
    name: Uptime
    id: sys_uptime
    update_interval: 60s

  # WiFi signal strength in dB
  - platform: wifi_signal
    name: RSSI
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"

  # ============================================================================
  # Display Health Sensors
  # ============================================================================

  # Display refresh rate monitor
  - platform: template
    name: "Display Refresh Count"
    id: display_refresh_counter
    internal: true
    update_interval: never
    entity_category: "diagnostic"

  # Display activity monitor - shows seconds since last display update
  - platform: template
    name: "Display Last Update"
    id: display_last_update_sensor
    lambda: |-
      if (id(last_display_update_time) == 0) return 0;
      return (millis() - id(last_display_update_time)) / 1000.0;
    unit_of_measurement: "s"
    accuracy_decimals: 0
    update_interval: 10s
    entity_category: "diagnostic"
    icon: "mdi:monitor-dashboard"

  # Display recovery counter - tracks automatic and manual recoveries
  - platform: template
    name: "Display Recovery Count"
    id: display_recovery_count
    entity_category: diagnostic
    accuracy_decimals: 0

  # ============================================================================
  # Performance Monitoring Sensors
  # ============================================================================

  # Weather icon update duration (internal diagnostic)
  - platform: template
    name: "Weather Icon Update Duration"
    id: weather_icon_duration_sensor
    internal: true  # Don't send to Home Assistant - internal diagnostic only
    unit_of_measurement: "ms"
    accuracy_decimals: 0
    icon: "mdi:weather-lightning"
    entity_category: "diagnostic"
    update_interval: never

  # ============================================================================
  # Memory Monitoring Sensors
  # ============================================================================

  # Internal heap monitoring
  - platform: template
    name: "Free Heap"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 5000.0       # Only send if changes by ±5KB
    #   - heartbeat: 60s      # Force update every 60s (reduced from 300s)

  - platform: template
    name: "Largest Free Block"
    lambda: return heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 5000.0       # Only send if changes by ±5KB
    #   - heartbeat: 60s      # Force update every 60s (reduced from 300s)

  - platform: template
    name: "Heap Fragmentation"
    lambda: |-
      size_t free_heap = heap_caps_get_free_size(MALLOC_CAP_INTERNAL);
      size_t largest_block = heap_caps_get_largest_free_block(MALLOC_CAP_INTERNAL);
      if (free_heap > 0) {
        return ((float)(free_heap - largest_block) / free_heap) * 100.0;
      }
      return 0.0;
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 2.0          # Only send if fragmentation changes by ±2%
    #   - heartbeat: 60s      # Force update every 60s (reduced from 300s)

  # DMA-capable memory monitoring
  - platform: template
    name: "DMA Capable Heap Free"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_DMA);
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 5000.0       # Only send if changes by ±5KB
    #   - heartbeat: 60s      # Force update every 60s (reduced from 300s)

  - platform: template
    name: "DMA Capable Largest Block"
    lambda: return heap_caps_get_largest_free_block(MALLOC_CAP_DMA);
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 5000.0       # Only send if changes by ±5KB
    #   - heartbeat: 60s      # Force update every 60s (reduced from 300s)

  # PSRAM monitoring (if available)
  - platform: template
    name: "PSRAM Free"
    lambda: |-
      size_t psram_free = heap_caps_get_free_size(MALLOC_CAP_SPIRAM);
      if (psram_free > 0) {
        return psram_free;
      }
      return 0;  // No PSRAM available
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 50000.0      # Only send if PSRAM changes by ±50KB
    #   - heartbeat: 120s     # Force update every 2 minutes (reduced from 300s)

  # Total free heap across all memory types
  - platform: template
    name: "Total Free Heap (All)"
    lambda: return heap_caps_get_free_size(MALLOC_CAP_8BIT);
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 50000.0      # Only send if total heap changes by ±50KB
    #   - heartbeat: 120s     # Force update every 2 minutes (reduced from 300s)

  # Minimum free heap since boot (indicates worst-case memory pressure)
  - platform: template
    name: "Min Free Heap Ever"
    lambda: return heap_caps_get_minimum_free_size(MALLOC_CAP_INTERNAL);
    unit_of_measurement: "bytes"
    update_interval: 5s
    entity_category: "diagnostic"
    # filters:
    #   - delta: 100.0       # Only send if min heap changes by ±1KB (important metric)
    #   - heartbeat: 60s      # Force update every 60s (reduced from 300s)

# ============================================================================
# Switch Components
# ============================================================================
switch:
  # Auto page rotation enable/disable
  - platform: template
    name: "Auto Page Rotation"
    id: auto_page_rotation
    icon: mdi:rotate-3d-variant
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(auto_page_rotation_enabled) = true;'
      - logger.log: "Auto page rotation enabled"
    on_turn_off:
      - lambda: 'id(auto_page_rotation_enabled) = false;'
      - logger.log: "Auto page rotation disabled"

  # Display watchdog automatic recovery
  - platform: template
    name: "Display Watchdog (Auto Recovery)"
    id: display_watchdog_switch
    icon: mdi:monitor-eye
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: |-
          id(display_watchdog_enabled) = true;
          id(last_display_update_time) = millis();  // Reset timer
      - logger.log: "Display watchdog enabled - will auto-recover from black screens"
    on_turn_off:
      - lambda: 'id(display_watchdog_enabled) = false;'
      - logger.log: "Display watchdog disabled"

  # Startup light blink effect
  - platform: template
    name: "Startup Light Blink"
    id: startup_light_blink
    icon: mdi:lightbulb
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"

# ============================================================================
# Button Components
# ============================================================================
button:
  # ESP32 restart button
  - platform: restart
    icon: mdi:power-cycle
    name: "ESP Reboot"
    id: esp_reboot_button

  # Factory reset (disabled by default for safety)
  - platform: factory_reset
    disabled_by_default: True
    name: "Factory Reset ESP"
    id: factory_reset_all

  # Clear Improv WiFi credentials button
  - platform: template
    name: "Clear Improv WiFi Credentials"
    id: clear_improv_wifi
    icon: mdi:wifi-off
    entity_category: config
    on_press:
      - lambda: |-
          // Clear only the Improv WiFi credentials from NVS (key: 0x9B5A7C21)
          auto pref = global_preferences->make_preference<uint8_t>(0x9B5A7C21);
          uint8_t dummy = 0;
          pref.save(&dummy);
          ESP_LOGI("main", "Cleared Improv WiFi credentials from NVS");
      - logger.log: "Improv WiFi credentials cleared. Device will use YAML WiFi config on next boot."

  # Display recovery button - AGGRESSIVE RESET
  # Use this when display goes black but backlight is still on
  # Performs complete hardware reset of display controller and LVGL
  - platform: template
    name: "Recover Display (Hard Reset)"
    id: recover_display
    icon: mdi:monitor-refresh
    on_press:
      - logger.log: "=== PERFORMING DISPLAY RECOVERY ==="
      - logger.log: "Step 1: Turning backlight OFF..."
      - output.turn_off: backlight
      - delay: 500ms

      - logger.log: "Step 2: Pausing LVGL..."
      - lvgl.pause:
      - delay: 300ms

      - logger.log: "Step 3: Resetting and re-initializing display controller..."
      - lambda: |-
          ESP_LOGI("display_reset", "Resetting and re-initializing display hardware...");
          auto *display = id(lily_display);
          if (display != nullptr) {
            display->setup();  // This re-initializes the display controller completely
          }
      - delay: 500ms

      - logger.log: "Step 4: Resuming LVGL..."
      - lvgl.resume:
      - delay: 300ms

      - logger.log: "Step 5: Turning backlight ON..."
      - output.turn_on: backlight
      - delay: 200ms

      - logger.log: "Step 6: Updating watchdog timestamp and recovery counter..."
      - lambda: |-
          // Update watchdog timestamp
          id(last_display_update_time) = millis();

          // Increment recovery counter
          static int recoveries = 0;
          recoveries++;
          id(display_recovery_count).publish_state(recoveries);

          ESP_LOGI("display_reset", "=== DISPLAY RECOVERY COMPLETE === (Recovery #%d)", recoveries);

      - logger.log: "Display recovery complete!"

# ============================================================================
# Interval Components
# ============================================================================
interval:
  # Display Watchdog - Automatic Black Screen Recovery
  # Checks every 30 seconds if display has been updating
  # If no updates for 60 seconds, performs automatic recovery
  - interval: 30s
    then:
      - if:
          condition:
            lambda: |-
              // Only run watchdog if enabled and boot is complete
              if (!id(display_watchdog_enabled) || !id(boot_complete)) {
                ESP_LOGV("display_watchdog", "Watchdog check skipped (enabled=%s, boot_complete=%s)",
                         id(display_watchdog_enabled) ? "true" : "false",
                         id(boot_complete) ? "true" : "false");
                return false;
              }

              const uint32_t now = millis();
              const uint32_t time_since_update = now - id(last_display_update_time);

              // Log watchdog check for debugging
              ESP_LOGD("display_watchdog", "Watchdog check: %u seconds since last display update", time_since_update / 1000);

              // If display hasn't updated in 60 seconds, trigger recovery
              if (time_since_update > 60000) {
                ESP_LOGW("display_watchdog", "Display frozen detected! No updates for %u seconds", time_since_update / 1000);
                return true;
              }
              return false;
          then:
            - logger.log: "=== WATCHDOG: AUTOMATIC DISPLAY RECOVERY TRIGGERED ==="
            - output.turn_off: backlight
            - delay: 500ms
            - lvgl.pause:
            - delay: 300ms
            # Properly reset and re-initialize the display controller
            - lambda: |-
                ESP_LOGI("display_watchdog", "Resetting and re-initializing display hardware...");
                auto *display = id(lily_display);
                if (display != nullptr) {
                  display->setup();  // This re-initializes the display controller completely
                }
            - delay: 500ms
            - lvgl.resume:
            - delay: 300ms
            - output.turn_on: backlight
            - delay: 200ms
            - lambda: |-
                // Update watchdog timestamp
                id(last_display_update_time) = millis();

                // Increment recovery counter
                static int recoveries = 0;
                recoveries++;
                id(display_recovery_count).publish_state(recoveries);

                ESP_LOGI("display_watchdog", "=== AUTOMATIC RECOVERY COMPLETE === (Recovery #%d)", recoveries);

  # Periodic Display Controller Health Check
  # The AXS15231 display controller can lose sync even while LVGL continues running
  - interval: 5min
    then:
      - if:
          condition:
            lambda: |-
              // Only run if watchdog is enabled and boot complete
              if (!id(display_watchdog_enabled) || !id(boot_complete)) return false;

              ESP_LOGI("display_health", "Performing periodic display controller health check");
              return true;
          then:
            - logger.log: "=== PERIODIC DISPLAY HEALTH CHECK ==="
            - output.turn_off: backlight
            - delay: 100ms
            - lvgl.pause:
            - delay: 100ms
            - lambda: |-
                auto *display = id(lily_display);
                if (display != nullptr) {
                  display->setup();  // Re-initialize display controller
                }
            - delay: 100ms
            - lvgl.resume:
            - delay: 100ms
            - output.turn_on: backlight
            - delay: 100ms
            - lambda: |-
                id(last_display_update_time) = millis();
                ESP_LOGI("display_health", "=== DISPLAY HEALTH CHECK COMPLETE ===");

# ============================================================================
# Boot Sequence Integration
# ============================================================================
# Display Watchdog Initialization (Priority 800)
#
# Initializes the watchdog timer early in boot sequence to prevent
# false positive recoveries during startup
# ============================================================================
esphome:
  on_boot:
    - priority: 800  # Very early - before most initialization
      then:
        - delay: 50ms
        - lambda: 'id(last_display_update_time) = millis();'  # Initialize watchdog timer
        - logger.log: "Display watchdog timer initialized"

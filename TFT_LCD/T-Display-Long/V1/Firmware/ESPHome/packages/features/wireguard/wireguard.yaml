# ============================================================================
# WireGuard VPN Capability Module
# ============================================================================
# Provides secure VPN tunnel to home network using WireGuard protocol
#
# FEATURES:
#   - Encrypted VPN tunnel configuration
#   - Connection status monitoring
#   - Enable/disable VPN control
#   - Latest handshake tracking
#   - VPN IP address display
#   - Delayed boot activation (for BLE memory stability)
#
# HARDWARE REQUIRED:
#   - ESP32 WiFi (built-in)
#   - WireGuard server endpoint accessible from device location
#
# DEPENDENCIES:
#   - system/esphome_core.yaml (ESP32 config)
#   - system/networking.yaml (WiFi must be connected first)
#
# MEMORY USAGE: ~8KB
#
# CONFIGURATION REQUIRED:
#   Secrets file must define:
#   - wg_address: VPN IP address (e.g., "10.1.0.2")
#   - wg_netmask: VPN subnet mask (e.g., "255.255.255.0")
#   - wg_prikey: Device private key
#   - wg_peerport: Server port (e.g., 51820)
#   - wg_peerendpt: Server endpoint (hostname or IP)
#   - wg_pubkey: Server public key
#   - wg_shrdkey: Pre-shared key (for additional security)
#   - wg_allowed_ips: Allowed VPN routes (e.g., "0.0.0.0/0")
#
# Created: 2025-11-14 (Phase 2 extraction)
# ============================================================================

# ============================================================================
# WireGuard VPN Configuration
# ============================================================================
wireguard:
  id: wg0
  address: !secret wg_address
  netmask: !secret wg_netmask
  private_key: !secret wg_prikey
  peer_port: !secret wg_peerport
  peer_endpoint: !secret wg_peerendpt
  peer_public_key: !secret wg_pubkey
  peer_preshared_key: !secret wg_shrdkey
  peer_allowed_ips: !secret wg_allowed_ips
  peer_persistent_keepalive: 25s
  require_connection_to_proceed: false  # Non-blocking boot

# ============================================================================
# Switch Components
# ============================================================================
switch:
  # Enable/disable WireGuard VPN connection
  - platform: template
    name: "Enable WireGuard"
    id: wireguard_enabled
    icon: mdi:vpn
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - logger.log: "WireGuard switch turned ON - enabling WireGuard"
      - delay: 500ms  # Brief delay for switch state to stabilize
      - wireguard.enable:
          id: wg0
      - logger.log: "✓ WireGuard enabled"
    on_turn_off:
      - logger.log: "WireGuard switch turned OFF - disabling WireGuard"
      - wireguard.disable:
          id: wg0
      - logger.log: "✓ WireGuard disabled"

# ============================================================================
# Binary Sensor Components
# ============================================================================
binary_sensor:
  # WireGuard connection status and enabled state
  - platform: wireguard
    wireguard_id: wg0
    status:
      name: "WireGuard Status"
      id: wireguard_status
      on_state:
        then:
          - lambda: |-
              std::string status_text = "Status: ";
              status_text += x ? "Connected" : "Disconnected";
              if (status_text != id(wg_status_last_text)) {
                id(wg_status_last_text) = status_text;
                id(wg_status_needs_render) = true;
              }
    enabled:
      name: "WireGuard Enabled"
      id: wireguard_enabled_sensor

# ============================================================================
# Sensor Components
# ============================================================================
sensor:
  # Latest handshake time (indicates connection health)
  - platform: wireguard
    wireguard_id: wg0
    latest_handshake:
      name: "WireGuard Latest Handshake"
      id: wireguard_handshake
      on_value:
        then:
          - lambda: |-
              char time_str[64];
              if (std::isnan(x) || x <= 0) {
                snprintf(time_str, sizeof(time_str), "Handshake: \nUnavailable");
              } else {
                int seconds = (int)x;
                int minutes = seconds / 60;
                int hours = minutes / 60;
                int days = hours / 24;

                if (days > 0) {
                  snprintf(time_str, sizeof(time_str), "Handshake: \n%dd %dh ago", days, hours % 24);
                } else if (hours > 0) {
                  snprintf(time_str, sizeof(time_str), "Handshake: \n%dh %dm ago", hours, minutes % 60);
                } else if (minutes > 0) {
                  snprintf(time_str, sizeof(time_str), "Handshake: \n%dm %ds ago", minutes, seconds % 60);
                } else {
                  snprintf(time_str, sizeof(time_str), "Handshake: \n%ds ago", seconds);
                }
              }
              std::string handshake_text(time_str);
              if (handshake_text != id(wg_handshake_last_text)) {
                id(wg_handshake_last_text) = handshake_text;
                id(wg_handshake_needs_render) = true;
              }

# ============================================================================
# Text Sensor Components
# ============================================================================
text_sensor:
  # VPN IP address assigned to this device
  - platform: wireguard
    wireguard_id: wg0
    address:
      name: "WireGuard Address"
      id: wireguard_address_text
      on_value:
        then:
          - lambda: |-
              std::string addr_text = "VPN IP: ";
              addr_text += x.empty() ? "Not assigned" : x;
              if (addr_text != id(wg_address_last_text)) {
                id(wg_address_last_text) = addr_text;
                id(wg_address_needs_render) = true;
              }

# ============================================================================
# Boot Sequence Integration
# ============================================================================
# WireGuard Delayed Start (Priority 50)
#
# DELAY RATIONALE: BLE initialization consumes significant memory
#   - Without delay: WireGuard + BLE can cause OOM crash
#   - With 20s delay: BLE stabilizes, memory usage predictable
#   - Timing chosen empirically through testing
#
# This boot hook enables WireGuard after BLE has fully initialized
# Only activates if the wireguard_enabled switch is ON
# ============================================================================
esphome:
  on_boot:
    - priority: 50
      then:
        - delay: 20s  # Allow BLE to fully initialize and stabilize memory
        - lambda: |-
            ESP_LOGI("wireguard_delayed", "Checking WireGuard enable state after 20s delay...");
            ESP_LOGI("wireguard_delayed", "Free internal heap: %d bytes", heap_caps_get_free_size(MALLOC_CAP_INTERNAL));
            ESP_LOGI("wireguard_delayed", "WireGuard switch state: %s", id(wireguard_enabled).state ? "ON" : "OFF");
        - if:
            condition:
              lambda: 'return id(wireguard_enabled).state;'
            then:
              - wireguard.enable:
                  id: wg0
              - logger.log: "✓ WireGuard enabled successfully"
            else:
              - logger.log: "WireGuard switch is OFF, not enabling at boot"

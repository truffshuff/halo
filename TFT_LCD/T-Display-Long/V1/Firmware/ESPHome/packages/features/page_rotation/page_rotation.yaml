# ============================================================================
# Page Rotation Capability Module
# ============================================================================
# Provides master controls for automatic page rotation functionality
#
# FEATURES:
#   - Master auto-rotation enable/disable switch
#   - Rotation interval configuration (5-300 seconds)
#   - Core rotation globals (enabled state, interval, timing)
#   - Current page tracking
#   - Touch event integration (resets rotation timer)
#
# ARCHITECTURE NOTE:
#   This module provides MASTER controls only. Individual page rotation
#   switches and order numbers remain in their capability modules:
#   - Clock: features/clock/clock_base.yaml
#   - AirQ: features/airq/airq_base.yaml
#   - WiFi: features/wifi_status/wifi_page_base.yaml
#   - Weather: Halo-v1-Core.yaml (will move to features/weather in Phase 3)
#
#   The actual rotation logic (interval that cycles pages) remains in
#   Halo-v1-Core.yaml as it needs to orchestrate across all pages.
#
# HARDWARE REQUIRED:
#   - Display with LVGL (for page switching)
#   - Touchscreen (optional, for touch-to-reset-timer)
#
# DEPENDENCIES:
#   - system/esphome_core.yaml (ESP32 config)
#   - system/display_hardware.yaml (Display, touchscreen)
#   - All page modules that participate in rotation
#
# MEMORY USAGE: ~1KB
#
# Created: 2025-11-14 (Phase 2 extraction)
# ============================================================================

# ============================================================================
# Globals (Master Page Rotation Controls)
# ============================================================================
globals:
  # Current page tracking using string name
  # Possible values: "vertical_clock", "airq", "wifi", "weather",
  #                  "hourly_forecast", "hourly_summary_1", "hourly_summary_2", "daily_forecast"
  - id: current_page_name
    type: std::string
    restore_value: no
    initial_value: '"vertical_clock"'

  # Auto page rotation master enable/disable
  # When true, device automatically cycles through enabled pages
  # Controllable via Home Assistant switch
  - id: auto_page_rotation_enabled
    type: bool
    restore_value: yes
    initial_value: 'true'

  # Auto page rotation interval (seconds)
  # How long to display each page before rotating to next
  # Default: 30 seconds. Adjustable via Home Assistant
  - id: auto_page_rotation_interval
    type: int
    restore_value: yes
    initial_value: '30'

  # Last auto-rotation timestamp
  # Tracks when last page rotation occurred (in milliseconds)
  # Used to calculate when next rotation should happen
  - id: last_auto_rotation_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

  # Last touch time tracking
  # Records timestamp (milliseconds) of last touchscreen interaction
  # Used to reset auto-rotation timer when user touches the display
  - id: last_touch_time
    type: int
    initial_value: '0'

# ============================================================================
# Number Components
# ============================================================================
number:
  # Auto page rotation interval control
  # Allows adjusting how long each page displays before rotating
  - platform: template
    name: "Auto Page Rotation Interval"
    id: page_rotation_interval
    icon: mdi:timer
    restore_value: true
    initial_value: 30
    min_value: 5
    max_value: 300
    entity_category: "config"
    unit_of_measurement: "s"
    optimistic: true
    step: 1
    mode: box
    on_value:
      - lambda: 'id(auto_page_rotation_interval) = (int)x;'
      - logger.log:
          format: "Page rotation interval changed to %d seconds"
          args: ['(int)x']

# ============================================================================
# Switch Components
# ============================================================================
switch:
  # Individual page enable/disable switches for rotation
  # These control which pages are included in the automatic rotation cycle

  # AirQ page rotation control
  - platform: template
    name: "Page Rotation: AirQ Page"
    id: page_rotation_AirQ_switch
    icon: mdi:view-dashboard
    restore_mode: RESTORE_DEFAULT_ON
    optimistic: true
    entity_category: "config"
    on_turn_on:
      - lambda: 'id(page_rotation_AirQ_enabled) = true;'
      - logger.log: "AirQ page enabled in rotation"
    on_turn_off:
      - lambda: 'id(page_rotation_AirQ_enabled) = false;'
      - logger.log: "AirQ page disabled in rotation"

# Note: Auto Page Rotation master switch is in diagnostics.yaml
# Note: Individual page switches for Clock, WiFi, Weather are in their respective capability modules

# ============================================================================
# Select Components
# ============================================================================
select:
  # Default page to display at boot
  # Allows user to choose which page appears when device starts
  - platform: template
    name: "Default Page at Boot"
    id: default_page_select_boot
    optimistic: true
    options:
      - "Vertical Clock"
      # Uncomment based on enabled features:
      # - "AirQ"          # if airq_enabled
      # - "WiFi"          # if wifi_enabled
      - "Weather"       # if weather_enabled
    initial_option: "Vertical Clock"
    restore_value: true

# ============================================================================
# Script Components
# ============================================================================
script:
  # Page transition cleanup script
  # Frees memory and refreshes display when transitioning between pages
  - id: page_transition_cleanup
    mode: queued  # Queue executions instead of warning about duplicates
    max_runs: 2   # Allow up to 2 queued runs
    then:
      - if:
          condition:
            lambda: 'return id(boot_complete) && !id(ota_in_progress);'
          then:
            - delay: 50ms  # Small delay to prevent rapid successive calls
            - lambda: |-
                // Safety check: Only run if LVGL is fully initialized
                lv_obj_t *scr = lv_scr_act();
                if (scr == NULL) {
                return;  // Silently skip if not initialized
                }

                // Log current memory state before cleanup
                ESP_LOGD("lvgl", "Page transition cleanup - Free heap: %d", esp_get_free_heap_size());

                // Clear all cached strings to free memory
                id(time_update_last_text).clear();
                id(weather_last_condition).clear();

                // Force LVGL to invalidate current screen and redraw
                lv_obj_invalidate(scr);

                // Force immediate display flush to prevent buffer buildup
                lv_refr_now(NULL);

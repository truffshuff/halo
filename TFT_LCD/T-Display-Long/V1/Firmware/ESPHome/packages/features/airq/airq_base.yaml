# ============================================================================
# Air Quality Capability Module
# ============================================================================
# Provides comprehensive air quality monitoring with multiple sensors
#
# SENSORS:
#   - SCD40: CO2 measurement with automatic pressure compensation
#   - MICS-4514: Multi-gas sensor (NO2, CO, H2, CH4, Ethanol, NH3)
#   - BME280: Temperature, humidity, pressure (baseline for other sensors)
#   - SEN55: Particulate matter (PM1.0, PM2.5, PM4.0, PM10.0), VOC, NOx
#   - Computed AQI: US EPA Air Quality Index from PM2.5
#
# FEATURES:
#   - Real-time air quality monitoring with color-coded thresholds
#   - CO2 calibration (two-step confirmation for safety)
#   - SEN55 fan cleaning for PM sensor maintenance
#   - Temperature unit selection (Fahrenheit/Celsius/Kelvin)
#   - Temperature and humidity offset calibration
#   - AQI-based LED color control
#
# HARDWARE REQUIRED:
#   - SCD40/SCD41 (I2C address: default)
#   - MICS-4514 (I2C address: 0x75)
#   - BME280 (I2C address: default)
#   - SEN55 (I2C address: 0x69)
#   - I2C bus (lily_i2c) configured in system/display_hardware.yaml
#
# DEPENDENCIES:
#   - system/esphome_core.yaml (ESP32 config)
#   - system/display_hardware.yaml (I2C bus)
#   - system/fonts_colors.yaml (colors for UI)
#
# MEMORY USAGE: ~15KB
#
# Created: 2025-11-14 (Phase 2 extraction)
# ============================================================================

# ============================================================================
# Globals
# ============================================================================
globals:
  # Temperature unit conversion flag
  # Triggers UI refresh when temperature unit is changed
  - id: temp_unit_changed
    type: bool
    initial_value: "true"

  # CO2 calibration safety flags
  # Two-step confirmation process to prevent accidental miscalibration
  - id: calibration_pending
    type: bool
    initial_value: 'false'
  - id: calibration_confirm_time
    type: uint32_t
    initial_value: '0'

# ============================================================================
# Select Components
# ============================================================================
select:
  - platform: template
    name: Display Temperature Unit
    id: display_temperature_unit
    entity_category: "Config"
    options:
     - "Fahrenheit"
     - "Celsius"
     - "Kelvin"
    initial_option: "Fahrenheit"
    restore_value: true
    optimistic: true
    on_value:
      - globals.set:
          id: temp_unit_changed
          value: "true"

# ============================================================================
# Number Components (Sensor Calibration)
# ============================================================================
number:
  - platform: template
    name: SEN55 Temperature Offset
    id: sen55_temperature_offset
    restore_value: true
    initial_value: 6.0
    min_value: -70.0
    max_value: 70.0
    entity_category: "CONFIG"
    unit_of_measurement: "°C"
    optimistic: true
    update_interval: never
    step: 0.1
    mode: box

  - platform: template
    name: SEN55 Humidity Offset
    id: sen55_humidity_offset
    restore_value: true
    initial_value: 0
    min_value: -70.0
    max_value: 70.0
    entity_category: "CONFIG"
    unit_of_measurement: "%"
    optimistic: true
    update_interval: never
    step: 0.1
    mode: box

# ============================================================================
# Sensor Platforms
# ============================================================================
sensor:
  # Computed AQI (US EPA Air Quality Index)
  # Calculated from PM2.5 data, controls LED color when "AQI Color" effect is selected
  - platform: template
    name: "Computed AQI"
    id: computed_halo_aqi
    unit_of_measurement: ""
    accuracy_decimals: 0
    device_class: "aqi"
    state_class: "measurement"
    update_interval: never  # Updated manually from PM2.5 sensor
    on_value:
      then:
        # Update LED effect when AQI changes if "AQI Color" effect is selected
        - if:
            condition:
              lambda: 'return id(led_effect_select).state == "AQI Color";'
            then:
              - lambda: |-
                  float aqi = x;
                  if (std::isnan(aqi) || aqi <= 50) {
                  auto call = id(rgb_light).turn_off();
                  call.perform();
                  } else {
                  Color color;
                  if (aqi <= 100) color = Color(255, 255, 0);       // yellow
                  else if (aqi <= 150) color = Color(255, 165, 0);  // orange
                  else if (aqi <= 200) color = Color(255, 0, 0);    // red
                  else if (aqi <= 300) color = Color(128, 0, 128);  // purple
                  else color = Color(128, 0, 0);                    // maroon
                  auto call = id(rgb_light).turn_on();
                  call.set_rgb(color.red / 255.0f, color.green / 255.0f, color.blue / 255.0f);
                  call.perform();
                  }

  # SCD4x CO2 Sensor (Sensirion SCD40/SCD41)
  # Automatic pressure compensation using BME280
  - platform: scd4x
    id: scd40
    co2:
      name: "CO2"
      id: "co2"
      filters:
        - throttle_average: 2s
        - delta: 10.0         # Only send to HA if CO2 changes by ±10 ppm
        - heartbeat: 120s     # Force update every 2 minutes even if no change
      on_value:
        then:
          - lvgl.label.update:
              id: co2_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%d", (int)x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 600;"
              then:
                - lvgl.label.update:
                    id: co2_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 1000;"
                    then:
                      - lvgl.label.update:
                          id: co2_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 1500;"
                          then:
                            - lvgl.label.update:
                                id: co2_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: co2_value
                                text_color: my_red
    automatic_self_calibration: false
    update_interval: 30s  # Increased from 10s to reduce I2C blocking frequency
    measurement_mode: "periodic"
    i2c_id: lily_i2c
    ambient_pressure_compensation_source: bme280pressure

  # MICS-4514 Multi-Gas Sensor
  # Measures NO2, CO, H2, CH4, Ethanol, NH3
  - platform: mics_4514
    id: mics4514
    nitrogen_dioxide:
      name: Nitrogen Dioxide
      id: "no2"
      filters:
      - offset: -0.16
      - throttle_average: 2s
      - delta: 0.01         # Only send if NO2 changes by ±0.01 ppm
      - heartbeat: 120s     # Force update every 2 minutes
      on_value:
        then:
          - lvgl.label.update:
              id: no2_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.02f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 0.03;"  # Safe level typical indoors (ppm)
              then:
                - lvgl.label.update:
                    id: no2_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 0.06;"  # Slightly elevated level (ppm)
                    then:
                      - lvgl.label.update:
                          id: no2_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 0.1;"  # Moderately high level (ppm)
                          then:
                            - lvgl.label.update:
                                id: no2_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: no2_value
                                text_color: my_red  # High level, unsafe indoors (ppm)
    carbon_monoxide:
      name: Carbon Monoxide
      id: "co"
      filters:
        - throttle_average: 2s
        - delta: 1.0          # Only send if CO changes by ±1 ppm
        - heartbeat: 120s     # Force update every 2 minutes
      on_value:
        then:
          - lvgl.label.update:
              id: co_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.02f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 15;"
              then:
                - lvgl.label.update:
                    id: co_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 30;"
                    then:
                      - lvgl.label.update:
                          id: co_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 36;"
                          then:
                            - lvgl.label.update:
                                id: co_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: co_value
                                text_color: my_red
    hydrogen:
      name: Hydrogen
      id: "h2"
      filters:
        - throttle_average: 2s
        - delta: 0.05         # Only send if H2 changes by ±0.05 ppm
        - heartbeat: 120s     # Force update every 2 minutes
      on_value:
        then:
          - lvgl.label.update:
              id: h2_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.02f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 0.4;"  # Safe level typical indoors
              then:
                - lvgl.label.update:
                    id: h2_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 1.0;"  # Slightly elevated level
                    then:
                      - lvgl.label.update:
                          id: h2_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 2.0;"  # Moderately high level
                          then:
                            - lvgl.label.update:
                                id: h2_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: h2_value
                                text_color: my_red  # High level, unsafe indoors
    methane:
      name: Methane
      id: "ch4"
      filters:
        - throttle_average: 2s
        - delta: 10.0         # Only send if CH4 changes by ±10 ppm
        - heartbeat: 120s     # Force update every 2 minutes
      on_value:
        then:
          - lvgl.label.update:
              id: ch4_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.02f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 2.0;"  # Typical safe level
              then:
                - lvgl.label.update:
                    id: ch4_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 10.0;"  # Elevated but not critical
                    then:
                      - lvgl.label.update:
                          id: ch4_value
                          text_color: my_yellow
                    else:
                      - lvgl.label.update:
                          id: ch4_value
                          text_color: my_red  # Critical level
    ethanol:
      name: Ethanol
      id: "ethanol"
      filters:
        - throttle_average: 2s
        - delta: 0.1          # Only send if ethanol changes by ±0.1 ppm
        - heartbeat: 120s     # Force update every 2 minutes
      on_value:
        then:
          - lvgl.label.update:
              id: ethanol_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.02f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 0.5;"  # Safe level
              then:
                - lvgl.label.update:
                    id: ethanol_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 1.5;"  # Slightly elevated
                    then:
                      - lvgl.label.update:
                          id: ethanol_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 3.0;"  # Moderate level
                          then:
                            - lvgl.label.update:
                                id: ethanol_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: ethanol_value
                                text_color: my_red  # High level
    ammonia:
      name: Ammonia
      id: "nh3"
      filters:
        - throttle_average: 2s
        - delta: 0.1          # Only send if ammonia changes by ±0.1 ppm
        - heartbeat: 120s     # Force update every 2 minutes
      on_value:
        then:
          - lvgl.label.update:
              id: nh3_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.02f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x <= 0.5;"  # Safe level typical indoors
              then:
                - lvgl.label.update:
                    id: nh3_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 1.0;"  # Slightly elevated level
                    then:
                      - lvgl.label.update:
                          id: nh3_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 2.0;"  # Moderately high level
                          then:
                            - lvgl.label.update:
                                id: nh3_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: nh3_value
                                text_color: my_red  # High level, unsafe indoors
    update_interval: 40s  # Increased from 12s to reduce I2C blocking frequency
    i2c_id: lily_i2c
    address: 0x75

  # BME280 Atmospheric Sensor
  # Provides baseline temperature, humidity, pressure
  # Pressure reading used for SCD4x CO2 compensation
  - platform: bme280_i2c
    i2c_id: lily_i2c
    temperature:
      name: "BME280 Temperature"
      oversampling: 2x
    pressure:
      name: "BME280 Pressure"
      id: bme280pressure  # Referenced by scd4x for pressure compensation
    humidity:
      name: "BME280 Humidity"

  # SEN55 Multi-Sensor (PM, VOC, NOx, Temperature, Humidity)
  # WARNING: Blocks I2C for 4+ seconds per read - long update interval required
  - platform: sen5x
    id: sen55
    pm_1_0:
      name: "PM <1µm Weight concentration"
      id: pm_1_0
      accuracy_decimals: 1
      filters:
        - throttle_average: 2s
      on_value:
        then:
          - lvgl.label.update:
              id: pm1_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.01f", x);
                return buffer;
    pm_2_5:
      name: "PM <2.5µm Weight concentration"
      id: pm_2_5
      accuracy_decimals: 1
      filters:
        - throttle_average: 2s
      on_value:
        then:
          - lvgl.label.update:
              id: pm25_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.01f", x);
                return buffer;
          - lvgl.label.update:
              id: aqi_value
              text: !lambda |-
                float val = x; // PM2.5 value
                float aqi = 0.0;

                if (val <= 9.0) {
                  aqi = ((50.0 - 0.0) / (9.0 - 0.0)) * (val - 0.0) + 0.0;
                } else if (val <= 35.4) {
                  aqi = ((100.0 - 51.0) / (35.4 - 9.1)) * (val - 9.1) + 51.0;
                } else if (val <= 55.4) {
                  aqi = ((150.0 - 101.0) / (55.4 - 35.5)) * (val - 35.5) + 101.0;
                } else if (val <= 125.4) {
                  aqi = ((200.0 - 151.0) / (125.4 - 55.5)) * (val - 55.5) + 151.0;
                } else if (val <= 225.4) {
                  aqi = ((300.0 - 201.0) / (225.4 - 125.5)) * (val - 125.5) + 201.0;
                } else if (val <= 500.4) {
                  aqi = ((500.0 - 301.0) / (500.4 - 250.5)) * (val - 250.5) + 301.0;
                } else {
                  return "EVAC";
                }

                static char buffer[10];
                snprintf(buffer, sizeof(buffer), " %d", (int)aqi);
                return buffer;

          - lvgl.widget.update:
              id: aqi_widget
              bg_color: !lambda |-
                float val = x; // PM2.5 value
                float aqi = 0.0;

                if (val <= 9.0) {
                  aqi = ((50.0 - 0.0) / (9.0 - 0.0)) * (val - 0.0) + 0.0;
                } else if (val <= 35.4) {
                  aqi = ((100.0 - 51.0) / (35.4 - 9.1)) * (val - 9.1) + 51.0;
                } else if (val <= 55.4) {
                  aqi = ((150.0 - 101.0) / (55.4 - 35.5)) * (val - 35.5) + 101.0;
                } else if (val <= 125.4) {
                  aqi = ((200.0 - 151.0) / (125.4 - 55.5)) * (val - 55.5) + 151.0;
                } else if (val <= 225.4) {
                  aqi = ((300.0 - 201.0) / (225.4 - 125.5)) * (val - 125.5) + 201.0;
                } else if (val <= 500.4) {
                  aqi = ((500.0 - 301.0) / (500.4 - 250.5)) * (val - 250.5) + 301.0;
                } else {
                  aqi = 500.0;
                }
                id(computed_halo_aqi).publish_state((int)aqi);

                // Return color based on AQI
                if (aqi <= 50) {
                  return lv_color_hex(0x76fa76); // Green
                } else if (aqi <= 100) {
                  return lv_color_hex(0xFFFF00); // Yellow
                } else if (aqi <= 150) {
                  return lv_color_hex(0xFFA500); // Orange
                } else if (aqi <= 200) {
                  return lv_color_hex(0xFF0000); // Red
                } else if (aqi <= 300) {
                  return lv_color_hex(0x800080); // Purple
                } else {
                  return lv_color_hex(0x800000); // Maroon
                }

    pm_4_0:
      name: "PM <4µm Weight concentration"
      id: pm_4_0
      accuracy_decimals: 1
      filters:
        - throttle_average: 2s
      on_value:
        then:
          - lvgl.label.update:
              id: pm4_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.01f", x);
                return buffer;
    pm_10_0:
      name: "PM <10µm Weight concentration"
      id: pm_10_0
      accuracy_decimals: 1
      filters:
        - throttle_average: 2s
      on_value:
        then:
          - lvgl.label.update:
              id: pm10_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%.01f", x);
                return buffer;
    temperature:
      name: "SEN55 Temperature"
      accuracy_decimals: 1
      filters:
        - offset: !lambda return -1.0 * id(sen55_temperature_offset).state;
        - throttle_average: 2s
      on_value:
        then:
          - if:
              condition:
                lambda: "return temp_unit_changed;"
              then:
                - lvgl.label.update:
                    id: temperature_units
                    text: !lambda |-
                      if(id(display_temperature_unit).state == "Fahrenheit")
                        return "\u00B0F";
                      else if(id(display_temperature_unit).state == "Kelvin")
                        return "K";
                      return "\u00B0C";
                - globals.set:
                    id: temp_unit_changed
                    value: "false"
          - lvgl.label.update:
              id: temperature_value
              text: !lambda |-
                static char buffer[10];
                if(id(display_temperature_unit).state == "Fahrenheit")
                  snprintf(buffer, sizeof(buffer), "%.01f", (x * 9.0 / 5.0) + 32.0);
                else if(id(display_temperature_unit).state == "Kelvin")
                  snprintf(buffer, sizeof(buffer), "%.01f", x + 273.15);
                else
                  snprintf(buffer, sizeof(buffer), "%.01f", x);
                return buffer;
          - if:
              condition:
                lambda: "return x >= 18 && x <= 24;"  # Comfortable temperature range (°C)
              then:
                - lvgl.label.update:
                    id: temperature_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return (x > 24 && x <= 27) || (x >= 16 && x < 18);"  # Slightly uncomfortable (°C)
                    then:
                      - lvgl.label.update:
                          id: temperature_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return (x > 27 && x <= 30) || (x >= 10 && x < 16);"  # Moderately uncomfortable (°C)
                          then:
                            - lvgl.label.update:
                                id: temperature_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: temperature_value
                                text_color: my_red  # Extreme discomfort or unsafe (°C)
    humidity:
      name: "SEN55 Humidity"
      filters:
        - lambda: return x - id(sen55_humidity_offset).state;
      accuracy_decimals: 0
      on_value:
        then:
          - lvgl.label.update:
              id: rh_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%d", (int)x);
                return buffer;
          - if:
              condition:
                lambda: "return x >= 30 && x <= 50;"  # Optimal indoor comfort range (%)
              then:
                - lvgl.label.update:
                    id: rh_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return (x > 50 && x <= 60) || (x >= 20 && x < 30);"  # Slightly out of comfort range (%)
                    then:
                      - lvgl.label.update:
                          id: rh_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return (x > 60 && x <= 70) || (x >= 10 && x < 20);"  # Moderately uncomfortable (%)
                          then:
                            - lvgl.label.update:
                                id: rh_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: rh_value
                                text_color: my_red  # Very uncomfortable or potentially hazardous (%)
    voc:
      name: "SEN55 VOC"
      id: sen55_voc
      algorithm_tuning:
        #https://sensirion.com/media/documents/25AB572C/62B463AA/Sensirion_Engineering_Guidelines_SEN5x.pdf
        index_offset: 100
        learning_time_offset_hours: 72
        learning_time_gain_hours: 72
        gating_max_duration_minutes: 180
        std_initial: 50
        gain_factor: 230
      on_value:
        then:
          - lvgl.label.update:
              id: voc_value
              text: !lambda |-
                static char buffer[10];
                snprintf(buffer, sizeof(buffer), "%3d", (int)x);
                return buffer;
          - if:
              condition:
                lambda: "return x < 150;"
              then:
                - lvgl.label.update:
                    id: voc_value
                    text_color: my_green
              else:
                - if:
                    condition:
                      lambda: "return x <= 250;"
                    then:
                      - lvgl.label.update:
                          id: voc_value
                          text_color: my_yellow
                    else:
                      - if:
                          condition:
                            lambda: "return x <= 400;"
                          then:
                            - lvgl.label.update:
                                id: voc_value
                                text_color: my_orange
                          else:
                            - lvgl.label.update:
                                id: voc_value
                                text_color: my_red
    i2c_id: lily_i2c
    address: 0x69
    update_interval: 60s  # Increased from 14s - SEN55 blocks for 4+ seconds per read!

# ============================================================================
# Button Components
# ============================================================================
button:
  # CO2 Calibration (Two-Step Process for Safety)
  # Step 1: Start calibration request
  - platform: template
    name: "Start CO2 Calibration (Requires Confirmation)"
    id: start_co2_calibration
    entity_category: config
    on_press:
      - logger.log:
          format: "CO2 calibration requested. Device must be outdoors. Press confirm button within 60 seconds."
          level: WARN
      - lambda: id(calibration_confirm_time) = millis();
      - globals.set:
          id: calibration_pending
          value: 'true'

  # Step 2: Confirm calibration (must be pressed within 60s of step 1)
  - platform: template
    name: "CONFIRM CO2 Calibration to 420ppm"
    id: confirm_co2_calibration
    entity_category: config
    disabled_by_default: true  # Hidden unless needed
    on_press:
      - if:
          condition:
            lambda: |-
                if (!id(calibration_pending)) {
                ESP_LOGW("calibration", "No calibration pending!");
                return false;
                }
                // Check if within 60-second confirmation window
                uint32_t elapsed = millis() - id(calibration_confirm_time);
                if (elapsed > 60000) {
                ESP_LOGW("calibration", "Confirmation timeout (>60s)");
                id(calibration_pending) = false;
                return false;
                }
                return true;
          then:
            - logger.log: "CO2 calibration confirmed. Calibrating to 420ppm..."
            - scd4x.perform_forced_calibration:
                value: 420
                id: scd40
            - logger.log: "CO2 calibration complete!"
            - globals.set:
                id: calibration_pending
                value: 'false'

  # SEN55 Fan Cleaning Cycle
  # Runs fan at high speed for 10 seconds to blow dust off PM sensor
  # Safe to use anytime, recommended if PM readings seem stuck or abnormally high
  - platform: template
    name: "Clean SEN55"
    id: clean_sen55
    entity_category: config
    on_press:
      - sen5x.start_fan_autoclean: sen55

  # Navigation button to Air Quality page
  - platform: template
    name: "Go to Air Quality Page"
    id: goto_airq_page
    icon: mdi:air-filter
    on_press:
      - logger.log: "Navigating to Air Quality page"
      - lambda: |-
          id(current_page_name) = "airq";
          id(last_auto_rotation_time) = millis();
      - lvgl.page.show:
          id: AirQ_page
          animation: OUT_LEFT
          time: 300ms

# ============================================================================
# API Services
# ============================================================================
api:
  services:
    # Custom CO2 calibration value
    # Allows setting arbitrary calibration value via Home Assistant
    # USAGE: esphome.halo_calibrate_co2_value co2_ppm=400
    - service: calibrate_co2_value
      variables:
        co2_ppm: float
      then:
        - scd4x.perform_forced_calibration:
            value: !lambda "return co2_ppm;"
            id: scd40

    # SEN55 Fan Cleaning
    # Runs fan at high speed for 10 seconds to remove dust from sensor
    # USAGE: esphome.halo_sen55_clean
    - service: sen55_clean
      then:
        - sen5x.start_fan_autoclean: sen55

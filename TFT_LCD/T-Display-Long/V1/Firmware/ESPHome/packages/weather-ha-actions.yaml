# ============================================================================
# Weather via Home Assistant Actions (ESPHome 2025.10.0+)
# ============================================================================
# This package uses the NEW Home Assistant Action Response feature to fetch
# weather data ON-DEMAND instead of maintaining 125 persistent sensors.
#
# ðŸš€ REVOLUTIONARY MEMORY SAVINGS:
#   - OLD approach: 125 sensors Ã— ~600 bytes = ~75KB RAM (always allocated)
#   - NEW approach: ~3KB RAM (only when fetching data)
#   - Memory savings: ~70KB+
#
# âœ… BLE COMPATIBILITY: YES! This approach is FULLY compatible with BLE!
#   - Minimal memory footprint (~3KB vs ~75KB)
#   - Data fetched only when viewing weather page
#   - Zero memory usage when not in use
#
# ðŸŽ¯ FEATURES:
#   - Full weather data (current + 10-day forecast + hourly)
#   - On-demand refresh (manual or automatic)
#   - Auto-refresh while on weather page
#   - No persistent sensor memory allocation
#
# Dependencies:
#   - ESPHome 2025.10.0 or later (for homeassistant.action responses)
#   - Home Assistant weather integration (e.g., weather.home)
#   - weather-core.yaml (for scripts/globals)
#   - weather-page-*.yaml (for display pages)
#
# Required Home Assistant Setup:
#   1. Weather entity for forecasts (e.g., weather.home)
#      - Can be from any weather integration: Met.no, OpenWeatherMap, etc.
#   2. Current temperature sensor (e.g., sensor.outdoor_temperature)
#   3. Apparent/feels-like temperature sensor (e.g., sensor.feels_like_temperature)
# ============================================================================

# ============================================================================
# CONFIGURATION
# ============================================================================
substitutions:
  # Your Home Assistant weather entity ID (for forecasts)
  weather_entity_id: "weather.home"

  # Your actual sensor entities for current conditions
  current_temp_sensor: "sensor.outdoor_temperature"
  apparent_temp_sensor: "sensor.feels_like_temperature"

  # Auto-refresh interval while on weather page (seconds)
  weather_refresh_interval: "300"  # 5 minutes

# ============================================================================
# GLOBALS - Lightweight storage for weather data
# ============================================================================
globals:
  # Current weather
  - id: weather_current_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_apparent_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_condition
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: weather_current_humidity
    type: float
    restore_value: no
    initial_value: 'NAN'

  # Forecast arrays (10 days)
  - id: weather_forecast_temp_high
    type: float[10]
    restore_value: no

  - id: weather_forecast_temp_low
    type: float[10]
    restore_value: no

  - id: weather_forecast_condition
    type: std::string[10]
    restore_value: no

  - id: weather_forecast_precip_prob
    type: float[10]
    restore_value: no

  # Hourly forecast arrays (24 hours)
  - id: weather_hourly_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_apparent_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_condition
    type: std::string[24]
    restore_value: no

  - id: weather_hourly_precip_prob
    type: float[24]
    restore_value: no

  # Tracking
  - id: weather_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: weather_on_weather_page
    type: bool
    restore_value: no
    initial_value: 'false'

# ============================================================================
# SCRIPTS - Weather data fetching and processing
# ============================================================================
script:
  # Main script to fetch all weather data via HA actions
  - id: fetch_weather_data
    mode: single
    then:
      - logger.log: "Fetching weather data from Home Assistant..."

      # Fetch daily forecast
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            type: daily
            entity_id: ${weather_entity_id}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "Processing daily forecast response...");

                // The response format is: { "weather.entity_id": { "forecast": [...] } }
                auto response_data = response;

                if (response_data.count("${weather_entity_id}") > 0) {
                  auto entity_data = response_data["${weather_entity_id}"];

                  if (entity_data.count("forecast") > 0) {
                    auto forecast_array = entity_data["forecast"];

                    int day_count = std::min((int)forecast_array.size(), 10);
                    ESP_LOGI("weather", "Found %d days of forecast data", day_count);

                    for (int i = 0; i < day_count; i++) {
                      auto day = forecast_array[i];

                      // Extract temperature high
                      if (day.count("temperature") > 0) {
                        id(weather_forecast_temp_high)[i] = day["temperature"].as<float>();
                      }

                      // Extract temperature low
                      if (day.count("templow") > 0) {
                        id(weather_forecast_temp_low)[i] = day["templow"].as<float>();
                      }

                      // Extract condition
                      if (day.count("condition") > 0) {
                        id(weather_forecast_condition)[i] = day["condition"].as<std::string>();
                      }

                      // Extract precipitation probability
                      if (day.count("precipitation_probability") > 0) {
                        id(weather_forecast_precip_prob)[i] = day["precipitation_probability"].as<float>();
                      }
                    }

                    ESP_LOGI("weather", "âœ“ Daily forecast data stored");
                  } else {
                    ESP_LOGW("weather", "No 'forecast' key in response");
                  }
                } else {
                  ESP_LOGW("weather", "Weather entity not found in response");
                }

      # Fetch hourly forecast
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            type: hourly
            entity_id: ${weather_entity_id}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "Processing hourly forecast response...");

                auto response_data = response;

                if (response_data.count("${weather_entity_id}") > 0) {
                  auto entity_data = response_data["${weather_entity_id}"];

                  if (entity_data.count("forecast") > 0) {
                    auto forecast_array = entity_data["forecast"];

                    int hour_count = std::min((int)forecast_array.size(), 24);
                    ESP_LOGI("weather", "Found %d hours of forecast data", hour_count);

                    for (int i = 0; i < hour_count; i++) {
                      auto hour = forecast_array[i];

                      // Extract temperature
                      if (hour.count("temperature") > 0) {
                        id(weather_hourly_temp)[i] = hour["temperature"].as<float>();
                      }

                      // Extract apparent temperature
                      if (hour.count("apparent_temperature") > 0) {
                        id(weather_hourly_apparent_temp)[i] = hour["apparent_temperature"].as<float>();
                      }

                      // Extract condition
                      if (hour.count("condition") > 0) {
                        id(weather_hourly_condition)[i] = hour["condition"].as<std::string>();
                      }

                      // Extract precipitation probability
                      if (hour.count("precipitation_probability") > 0) {
                        id(weather_hourly_precip_prob)[i] = hour["precipitation_probability"].as<float>();
                      }
                    }

                    ESP_LOGI("weather", "âœ“ Hourly forecast data stored");
                  }
                }

      # Fetch current weather condition from the weather entity state
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${weather_entity_id}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "Processing current weather condition...");

                auto response_data = response;

                if (response_data.count("state") > 0) {
                  id(weather_current_condition) = response_data["state"].as<std::string>();
                }

                // Extract humidity from weather entity
                if (response_data.count("attributes") > 0) {
                  auto attrs = response_data["attributes"];
                  if (attrs.count("humidity") > 0) {
                    id(weather_current_humidity) = attrs["humidity"].as<float>();
                  }
                }

      # Fetch current temperature from sensor
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${current_temp_sensor}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "Processing current temperature...");

                auto response_data = response;

                if (response_data.count("state") > 0) {
                  std::string temp_str = response_data["state"].as<std::string>();
                  try {
                    id(weather_current_temp) = std::stof(temp_str);
                  } catch (...) {
                    ESP_LOGW("weather", "Failed to parse current temperature");
                    id(weather_current_temp) = NAN;
                  }
                }

      # Fetch apparent temperature from sensor
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${apparent_temp_sensor}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "Processing apparent temperature...");

                auto response_data = response;

                if (response_data.count("state") > 0) {
                  std::string temp_str = response_data["state"].as<std::string>();
                  try {
                    id(weather_current_apparent_temp) = std::stof(temp_str);
                  } catch (...) {
                    ESP_LOGW("weather", "Failed to parse apparent temperature");
                    id(weather_current_apparent_temp) = NAN;
                  }
                }

                // Update timestamp
                id(weather_last_update) = millis();

                ESP_LOGI("weather", "âœ“ Weather data fetch complete!");
                ESP_LOGI("weather", "Current: %.1fÂ°F (feels like %.1fÂ°F), %s",
                         id(weather_current_temp),
                         id(weather_current_apparent_temp),
                         id(weather_current_condition).c_str());

  # Script to update LVGL display with fetched data
  - id: update_weather_display
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("weather", "Updating weather display...");

          // Update current weather labels (if they exist)
          // Note: These label IDs must match your weather-page-*.yaml files

          // Current temperature
          if (!isnan(id(weather_current_temp))) {
            char temp_str[16];
            snprintf(temp_str, sizeof(temp_str), "%.0fÂ°F", id(weather_current_temp));
            // id(lbl_weather_today_outdoor_temp).set_text(temp_str);
          }

          // Update forecast days (Day 1-10)
          for (int i = 0; i < 10; i++) {
            if (!isnan(id(weather_forecast_temp_high)[i])) {
              // Update your forecast labels here
              // Example: id(lbl_forecast_day1_high).set_text(...)
            }
          }

          // Update hourly forecast (Hour 1-24)
          for (int i = 0; i < 24; i++) {
            if (!isnan(id(weather_hourly_temp)[i])) {
              // Update your hourly labels here
              // Example: id(lbl_hourly_temp_1).set_text(...)
            }
          }

          ESP_LOGI("weather", "âœ“ Display updated");

# ============================================================================
# BUTTONS - Manual refresh controls
# ============================================================================
button:
  - platform: template
    name: "Refresh Weather"
    id: btn_refresh_weather
    on_press:
      - script.execute: fetch_weather_data

# ============================================================================
# INTERVAL - Auto-refresh while on weather page
# ============================================================================
interval:
  # Auto-refresh weather data periodically while viewing weather page
  - interval: ${weather_refresh_interval}s
    then:
      - if:
          condition:
            lambda: 'return id(weather_on_weather_page);'
          then:
            - logger.log: "Auto-refreshing weather (on weather page)..."
            - script.execute: fetch_weather_data

# ============================================================================
# BOOT SEQUENCE
# ============================================================================
esphome:
  on_boot:
    - priority: -100
      then:
        # Fetch initial weather data after boot
        - delay: 5s
        - logger.log: "Initial weather data fetch..."
        - script.execute: fetch_weather_data

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================
# You can add these to your weather page YAML files to track when user
# is viewing the weather page:
#
# In your weather page's on_load event:
#   - lambda: 'id(weather_on_weather_page) = true;'
#   - script.execute: fetch_weather_data
#
# In your weather page's on_unload event (if available):
#   - lambda: 'id(weather_on_weather_page) = false;'
#
# This ensures weather refreshes automatically while viewing, but stops
# when the user navigates away.
# ============================================================================

# ============================================================================
# USAGE NOTES
# ============================================================================
# 1. This package provides the data fetching mechanism
# 2. You'll need to update your weather-page-*.yaml files to use the globals
#    instead of sensor IDs
# 3. Example label update:
#      text: !lambda |-
#        char buf[16];
#        snprintf(buf, sizeof(buf), "%.0fÂ°F", id(weather_forecast_temp_high)[0]);
#        return buf;
# 4. The display update lambda needs to be customized for your specific
#    label IDs from your existing weather pages
# ============================================================================

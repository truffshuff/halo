# ============================================================================
# Weather via Home Assistant Actions (ESPHome 2025.10.0+)
# ============================================================================
# This package uses the NEW Home Assistant Action Response feature to fetch
# weather data ON-DEMAND instead of maintaining 125 persistent sensors.
#
# ðŸš€ REVOLUTIONARY MEMORY SAVINGS:
#   - OLD approach: 125 sensors Ã— ~600 bytes = ~75KB RAM (always allocated)
#   - NEW approach: ~3KB RAM (only when fetching data)
#   - Memory savings: ~70KB+
#
# âœ… BLE COMPATIBILITY: YES! This approach is FULLY compatible with BLE!
#   - Minimal memory footprint (~3KB vs ~75KB)
#   - Data fetched only when viewing weather page
#   - Zero memory usage when not in use
#
# ðŸŽ¯ FEATURES:
#   - Full weather data (current + 10-day forecast + hourly)
#   - On-demand refresh (manual or automatic)
#   - Auto-refresh while on weather page
#   - No persistent sensor memory allocation
#
# Dependencies:
#   - ESPHome 2025.10.0 or later (for homeassistant.action responses)
#   - Home Assistant weather integration (e.g., weather.home)
#   - weather-core.yaml (for scripts/globals)
#   - weather-page-*.yaml (for display pages)
#
# Required Home Assistant Setup:
#   You need a weather entity in Home Assistant (e.g., weather.home)
#   This can be from any weather integration: Met.no, OpenWeatherMap, etc.
# ============================================================================

# ============================================================================
# CONFIGURATION
# ============================================================================
substitutions:
  # Your Home Assistant weather entity ID
  weather_entity_id: "weather.home"

  # Auto-refresh interval while on weather page (seconds)
  weather_refresh_interval: "300"  # 5 minutes

# ============================================================================
# GLOBALS - Lightweight storage for weather data
# ============================================================================
globals:
  # Current weather
  - id: weather_current_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_condition
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: weather_current_humidity
    type: float
    restore_value: no
    initial_value: 'NAN'

  # Forecast arrays (10 days)
  - id: weather_forecast_temp_high
    type: float[10]
    restore_value: no

  - id: weather_forecast_temp_low
    type: float[10]
    restore_value: no

  - id: weather_forecast_condition
    type: std::string[10]
    restore_value: no

  - id: weather_forecast_precip_prob
    type: float[10]
    restore_value: no

  # Hourly forecast arrays (24 hours)
  - id: weather_hourly_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_condition
    type: std::string[24]
    restore_value: no

  - id: weather_hourly_precip_prob
    type: float[24]
    restore_value: no

  # Tracking
  - id: weather_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: weather_on_weather_page
    type: bool
    restore_value: no
    initial_value: 'false'

# ============================================================================
# SCRIPTS - Weather data fetching and processing
# ============================================================================
script:
  # Main script to fetch all weather data via HA actions
  - id: fetch_weather_data
    mode: single
    then:
      - logger.log: "Fetching weather data from Home Assistant..."

      # Fetch daily forecast
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            type: daily
          target:
            entity_id: ${weather_entity_id}
          response_variable: daily_forecast

      # Process daily forecast response
      - lambda: |-
          ESP_LOGI("weather", "Processing daily forecast response...");

          // The response format is: { "weather.entity_id": { "forecast": [...] } }
          // We need to access: daily_forecast["${weather_entity_id}"]["forecast"]

          if (daily_forecast.count("${weather_entity_id}") > 0) {
            auto entity_data = daily_forecast["${weather_entity_id}"];

            if (entity_data.count("forecast") > 0) {
              auto forecast_array = entity_data["forecast"];

              int day_count = std::min((int)forecast_array.size(), 10);
              ESP_LOGI("weather", "Found %d days of forecast data", day_count);

              for (int i = 0; i < day_count; i++) {
                auto day = forecast_array[i];

                // Extract temperature high
                if (day.count("temperature") > 0) {
                  id(weather_forecast_temp_high)[i] = day["temperature"].as<float>();
                }

                // Extract temperature low
                if (day.count("templow") > 0) {
                  id(weather_forecast_temp_low)[i] = day["templow"].as<float>();
                }

                // Extract condition
                if (day.count("condition") > 0) {
                  id(weather_forecast_condition)[i] = day["condition"].as<std::string>();
                }

                // Extract precipitation probability
                if (day.count("precipitation_probability") > 0) {
                  id(weather_forecast_precip_prob)[i] = day["precipitation_probability"].as<float>();
                }
              }

              ESP_LOGI("weather", "âœ“ Daily forecast data stored");
            } else {
              ESP_LOGW("weather", "No 'forecast' key in response");
            }
          } else {
            ESP_LOGW("weather", "Weather entity not found in response");
          }

      # Fetch hourly forecast
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            type: hourly
          target:
            entity_id: ${weather_entity_id}
          response_variable: hourly_forecast

      # Process hourly forecast response
      - lambda: |-
          ESP_LOGI("weather", "Processing hourly forecast response...");

          if (hourly_forecast.count("${weather_entity_id}") > 0) {
            auto entity_data = hourly_forecast["${weather_entity_id}"];

            if (entity_data.count("forecast") > 0) {
              auto forecast_array = entity_data["forecast"];

              int hour_count = std::min((int)forecast_array.size(), 24);
              ESP_LOGI("weather", "Found %d hours of forecast data", hour_count);

              for (int i = 0; i < hour_count; i++) {
                auto hour = forecast_array[i];

                // Extract temperature
                if (hour.count("temperature") > 0) {
                  id(weather_hourly_temp)[i] = hour["temperature"].as<float>();
                }

                // Extract condition
                if (hour.count("condition") > 0) {
                  id(weather_hourly_condition)[i] = hour["condition"].as<std::string>();
                }

                // Extract precipitation probability
                if (hour.count("precipitation_probability") > 0) {
                  id(weather_hourly_precip_prob)[i] = hour["precipitation_probability"].as<float>();
                }
              }

              ESP_LOGI("weather", "âœ“ Hourly forecast data stored");
            }
          }

      # Fetch current weather from the weather entity state
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${weather_entity_id}
          response_variable: current_weather

      # Process current weather
      - lambda: |-
          ESP_LOGI("weather", "Processing current weather...");

          if (current_weather.count("state") > 0) {
            id(weather_current_condition) = current_weather["state"].as<std::string>();
          }

          // Extract attributes
          if (current_weather.count("attributes") > 0) {
            auto attrs = current_weather["attributes"];

            if (attrs.count("temperature") > 0) {
              id(weather_current_temp) = attrs["temperature"].as<float>();
            }

            if (attrs.count("humidity") > 0) {
              id(weather_current_humidity) = attrs["humidity"].as<float>();
            }
          }

          // Update timestamp
          id(weather_last_update) = millis();

          ESP_LOGI("weather", "âœ“ Weather data fetch complete!");
          ESP_LOGI("weather", "Current: %.1fÂ°F, %s", id(weather_current_temp), id(weather_current_condition).c_str());

      # Update the display
      - script.execute: update_weather_display

  # Script to update LVGL display with fetched data
  - id: update_weather_display
    mode: single
    then:
      - lambda: |-
          ESP_LOGI("weather", "Updating weather display...");

          // Update current weather labels (if they exist)
          // Note: These label IDs must match your weather-page-*.yaml files

          // Current temperature
          if (!isnan(id(weather_current_temp))) {
            char temp_str[16];
            snprintf(temp_str, sizeof(temp_str), "%.0fÂ°F", id(weather_current_temp));
            // id(lbl_weather_today_outdoor_temp).set_text(temp_str);
          }

          // Update forecast days (Day 1-10)
          for (int i = 0; i < 10; i++) {
            if (!isnan(id(weather_forecast_temp_high)[i])) {
              // Update your forecast labels here
              // Example: id(lbl_forecast_day1_high).set_text(...)
            }
          }

          // Update hourly forecast (Hour 1-24)
          for (int i = 0; i < 24; i++) {
            if (!isnan(id(weather_hourly_temp)[i])) {
              // Update your hourly labels here
              // Example: id(lbl_hourly_temp_1).set_text(...)
            }
          }

          ESP_LOGI("weather", "âœ“ Display updated");

# ============================================================================
# BUTTONS - Manual refresh controls
# ============================================================================
button:
  - platform: template
    name: "Refresh Weather"
    id: btn_refresh_weather
    on_press:
      - script.execute: fetch_weather_data

# ============================================================================
# INTERVAL - Auto-refresh while on weather page
# ============================================================================
interval:
  # Auto-refresh weather data periodically while viewing weather page
  - interval: ${weather_refresh_interval}s
    then:
      - if:
          condition:
            lambda: 'return id(weather_on_weather_page);'
          then:
            - logger.log: "Auto-refreshing weather (on weather page)..."
            - script.execute: fetch_weather_data

# ============================================================================
# BOOT SEQUENCE
# ============================================================================
esphome:
  on_boot:
    - priority: -100
      then:
        # Fetch initial weather data after boot
        - delay: 5s
        - logger.log: "Initial weather data fetch..."
        - script.execute: fetch_weather_data

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================
# You can add these to your weather page YAML files to track when user
# is viewing the weather page:
#
# In your weather page's on_load event:
#   - lambda: 'id(weather_on_weather_page) = true;'
#   - script.execute: fetch_weather_data
#
# In your weather page's on_unload event (if available):
#   - lambda: 'id(weather_on_weather_page) = false;'
#
# This ensures weather refreshes automatically while viewing, but stops
# when the user navigates away.
# ============================================================================

# ============================================================================
# USAGE NOTES
# ============================================================================
# 1. This package provides the data fetching mechanism
# 2. You'll need to update your weather-page-*.yaml files to use the globals
#    instead of sensor IDs
# 3. Example label update:
#      text: !lambda |-
#        char buf[16];
#        snprintf(buf, sizeof(buf), "%.0fÂ°F", id(weather_forecast_temp_high)[0]);
#        return buf;
# 4. The display update lambda needs to be customized for your specific
#    label IDs from your existing weather pages
# ============================================================================

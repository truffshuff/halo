# ============================================================================
# Weather via Home Assistant Actions (ESPHome 2025.10.0+)
# ============================================================================
# This package uses the NEW Home Assistant Action Response feature to fetch
# weather data ON-DEMAND instead of maintaining 125 persistent sensors.
#
# ðŸš€ REVOLUTIONARY MEMORY SAVINGS:
#   - OLD approach: 125 sensors Ã— ~600 bytes = ~75KB RAM (always allocated)
#   - NEW approach: ~3KB RAM (only when fetching data)
#   - Memory savings: ~70KB+
#
# âœ… BLE COMPATIBILITY: YES! This approach is FULLY compatible with BLE!
#   - Minimal memory footprint (~3KB vs ~75KB)
#   - Data fetched only when viewing weather page
#   - Zero memory usage when not in use
#
# ðŸŽ¯ FEATURES:
#   - Full weather data (current + 10-day forecast + hourly)
#   - On-demand refresh (manual or automatic)
#   - Auto-refresh while on weather page
#   - No persistent sensor memory allocation
#
# Dependencies:
#   - ESPHome 2025.10.0 or later (for homeassistant.action responses)
#   - Home Assistant weather integration (e.g., weather.home)
#   - weather-core.yaml (for scripts/globals)
#   - weather-page-*.yaml (for display pages)
#
# Required Home Assistant Setup:
#   1. Weather entity for forecasts (e.g., weather.home)
#      - Can be from any weather integration: Met.no, OpenWeatherMap, etc.
#   2. Current temperature sensor (e.g., sensor.outdoor_temperature)
#   3. Apparent/feels-like temperature sensor (e.g., sensor.feels_like_temperature)
# ============================================================================

# ============================================================================
# CONFIGURATION
# ============================================================================
# NOTE: Entity IDs are defined in your device YAML file (e.g., halo-v1-79e384.yaml)
# Required substitutions:
#   - weather_entity_id: Your Home Assistant weather entity (e.g., "weather.hhut")
#   - current_temp_sensor: Your temperature sensor (e.g., "sensor.hhut_temperature")
#   - apparent_temp_sensor: Your feels-like sensor (e.g., "sensor.hhut_feels_like")
#   - weather_refresh_interval: Auto-refresh interval in seconds (e.g., "900")

# ============================================================================
# GLOBALS - Lightweight storage for weather data
# ============================================================================
globals:
  # Current weather
  - id: weather_current_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_apparent_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_condition
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: weather_current_humidity
    type: float
    restore_value: no
    initial_value: 'NAN'

  # Forecast arrays (10 days)
  - id: weather_forecast_temp_high
    type: float[10]
    restore_value: no

  - id: weather_forecast_temp_low
    type: float[10]
    restore_value: no

  - id: weather_forecast_condition
    type: std::string[10]
    restore_value: no

  - id: weather_forecast_precip_prob
    type: float[10]
    restore_value: no

  # Hourly forecast arrays (24 hours)
  - id: weather_hourly_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_apparent_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_condition
    type: std::string[24]
    restore_value: no

  - id: weather_hourly_precip_prob
    type: float[24]
    restore_value: no

  # Tracking
  - id: weather_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: weather_on_weather_page
    type: bool
    restore_value: no
    initial_value: 'false'

# ============================================================================
# SCRIPTS - Weather data fetching and processing
# ============================================================================
script:
  # Main script to fetch all weather data via HA actions
  - id: fetch_weather_data
    mode: single
    then:
      - logger.log: "Fetching weather data from Home Assistant..."

      # Fetch daily forecast
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            type: daily
            entity_id: ${weather_entity_id}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "âœ“ Daily forecast response received");
                
                // Access the forecast data - response is already the root object
                if (response.containsKey("${weather_entity_id}")) {
                  auto entity_data = response["${weather_entity_id}"];
                  
                  if (entity_data.containsKey("forecast")) {
                    auto forecast_array = entity_data["forecast"];
                    int day_count = std::min((int)forecast_array.size(), 10);
                    ESP_LOGI("weather", "Found %d days of forecast data", day_count);
                    
                    for (int i = 0; i < day_count; i++) {
                      auto day = forecast_array[i];
                      
                      if (day.containsKey("temperature")) {
                        id(weather_forecast_temp_high)[i] = day["temperature"].as<float>();
                      }
                      
                      if (day.containsKey("templow")) {
                        id(weather_forecast_temp_low)[i] = day["templow"].as<float>();
                      }
                      
                      if (day.containsKey("condition")) {
                        id(weather_forecast_condition)[i] = day["condition"].as<std::string>();
                      }
                      
                      if (day.containsKey("precipitation_probability")) {
                        id(weather_forecast_precip_prob)[i] = day["precipitation_probability"].as<float>();
                      }
                    }
                    ESP_LOGI("weather", "âœ“ Daily forecast stored");
                  } else {
                    ESP_LOGW("weather", "No 'forecast' key in daily response");
                  }
                } else {
                  ESP_LOGW("weather", "Entity '${weather_entity_id}' not found in daily response");
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "âœ— Daily forecast fetch FAILED");

      # Fetch hourly forecast
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            type: hourly
            entity_id: ${weather_entity_id}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "âœ“ Hourly forecast response received");
                
                if (response.containsKey("${weather_entity_id}")) {
                  auto entity_data = response["${weather_entity_id}"];
                  
                  if (entity_data.containsKey("forecast")) {
                    auto forecast_array = entity_data["forecast"];
                    int hour_count = std::min((int)forecast_array.size(), 24);
                    ESP_LOGI("weather", "Found %d hours of forecast data", hour_count);
                    
                    for (int i = 0; i < hour_count; i++) {
                      auto hour = forecast_array[i];
                      
                      if (hour.containsKey("temperature")) {
                        id(weather_hourly_temp)[i] = hour["temperature"].as<float>();
                      }
                      
                      if (hour.containsKey("apparent_temperature")) {
                        id(weather_hourly_apparent_temp)[i] = hour["apparent_temperature"].as<float>();
                      }
                      
                      if (hour.containsKey("condition")) {
                        id(weather_hourly_condition)[i] = hour["condition"].as<std::string>();
                      }
                      
                      if (hour.containsKey("precipitation_probability")) {
                        id(weather_hourly_precip_prob)[i] = hour["precipitation_probability"].as<float>();
                      }
                    }
                    ESP_LOGI("weather", "âœ“ Hourly forecast stored");
                  } else {
                    ESP_LOGW("weather", "No 'forecast' key in hourly response");
                  }
                } else {
                  ESP_LOGW("weather", "Entity '${weather_entity_id}' not found in hourly response");
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "âœ— Hourly forecast fetch FAILED");

      # Fetch current weather condition
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${weather_entity_id}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "âœ“ Current weather response received");
                
                if (response.containsKey("state")) {
                  id(weather_current_condition) = response["state"].as<std::string>();
                  ESP_LOGD("weather", "Condition: %s", id(weather_current_condition).c_str());
                }
                
                if (response.containsKey("attributes")) {
                  auto attrs = response["attributes"];
                  if (attrs.containsKey("humidity")) {
                    id(weather_current_humidity) = attrs["humidity"].as<float>();
                  }
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "âœ— Current weather fetch FAILED");

      # Fetch current temperature
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${current_temp_sensor}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "âœ“ Current temp response received");
                
                if (response.containsKey("state")) {
                  float temp = response["state"].as<float>();
                  if (!isnan(temp)) {
                    id(weather_current_temp) = temp;
                    ESP_LOGD("weather", "Temp: %.1fÂ°F", temp);
                  }
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "âœ— Current temp fetch FAILED");

      # Fetch apparent temperature
      - homeassistant.action:
          action: homeassistant.get_state
          data:
            entity_id: ${apparent_temp_sensor}
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "âœ“ Apparent temp response received");
                
                if (response.containsKey("state")) {
                  float temp = response["state"].as<float>();
                  if (!isnan(temp)) {
                    id(weather_current_apparent_temp) = temp;
                    ESP_LOGD("weather", "Feels like: %.1fÂ°F", temp);
                  }
                }
                
                // Update timestamp
                id(weather_last_update) = millis();
                
                ESP_LOGI("weather", "âœ“ Weather data fetch complete!");
                ESP_LOGI("weather", "Current: %.1fÂ°F (feels like %.1fÂ°F), %s",
                         id(weather_current_temp),
                         id(weather_current_apparent_temp),
                         id(weather_current_condition).c_str());
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "âœ— Apparent temp fetch FAILED");

      # Update the display after fetching data
      - script.execute: update_weather_display

  # Script to update LVGL display with fetched data
  - id: update_weather_display
    mode: single
    then:
      - lvgl.label.update:
          id: lbl_weather_forecast_condition_name
          text: !lambda |-
            if (id(weather_current_condition).empty()) {
              return std::string("Unknown");
            }
            return id(weather_current_condition);

      - lvgl.label.update:
          id: lbl_weather_today_outdoor_temp
          text: !lambda |-
            if (isnan(id(weather_current_temp))) {
              return std::string("--.- Â°F");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.1f Â°F", id(weather_current_temp));
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_today_tempap
          text: !lambda |-
            if (isnan(id(weather_current_apparent_temp))) {
              return std::string("--Â°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.0fÂ°", id(weather_current_apparent_temp));
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_forecast_temphi
          text: !lambda |-
            if (isnan(id(weather_forecast_temp_high)[0])) {
              return std::string("H: --Â°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "H: %.0fÂ°", id(weather_forecast_temp_high)[0]);
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_forecast_templo
          text: !lambda |-
            if (isnan(id(weather_forecast_temp_low)[0])) {
              return std::string("L: --Â°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "L: %.0fÂ°", id(weather_forecast_temp_low)[0]);
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_today_dailyprecipprob
          text: !lambda |-
            if (isnan(id(weather_forecast_precip_prob)[0])) {
              return std::string("Chance: --%");
            }
            char buf[32];
            snprintf(buf, sizeof(buf), "Chance: %.0f%%", id(weather_forecast_precip_prob)[0]);
            return std::string(buf);

      - logger.log: "âœ“ Weather display labels updated"

# ============================================================================
# BUTTONS - Manual refresh controls
# ============================================================================
button:
  - platform: template
    name: "Refresh Weather"
    id: btn_refresh_weather
    on_press:
      - script.execute: fetch_weather_data

# ============================================================================
# INTERVAL - Auto-refresh while on weather page
# ============================================================================
interval:
  # Auto-refresh weather data periodically while viewing weather page
  - interval: ${weather_refresh_interval}s
    then:
      - if:
          condition:
            lambda: 'return id(weather_on_weather_page);'
          then:
            - logger.log: "Auto-refreshing weather data..."
            - script.execute: fetch_weather_data

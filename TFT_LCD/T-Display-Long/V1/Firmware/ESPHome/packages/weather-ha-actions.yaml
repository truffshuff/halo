# ============================================================================
# Weather via Home Assistant Actions (ESPHome 2025.10.0+)
# ============================================================================
# This package uses the NEW Home Assistant Action Response feature to fetch
# weather data ON-DEMAND instead of maintaining 125 persistent sensors.
#
# 🚀 REVOLUTIONARY MEMORY SAVINGS:
#   - OLD approach: 125 sensors × ~600 bytes = ~75KB RAM (always allocated)
#   - NEW approach: ~3KB RAM (only when fetching data)
#   - Memory savings: ~70KB+
#
# ✅ BLE COMPATIBILITY: YES! This approach is FULLY compatible with BLE!
#   - Minimal memory footprint (~3KB vs ~75KB)
#   - Data fetched only when viewing weather page
#   - Zero memory usage when not in use
#
# 🎯 FEATURES:
#   - Full weather data (current + 10-day forecast + hourly)
#   - On-demand refresh (manual or automatic)
#   - Auto-refresh while on weather page
#   - No persistent sensor memory allocation
#
# Dependencies:
#   - ESPHome 2025.10.0 or later (for homeassistant.action responses)
#   - Home Assistant weather integration (e.g., weather.home)
#   - weather-core.yaml (for scripts/globals)
#   - weather-page-*.yaml (for display pages)
#
# Required Home Assistant Setup:
#   1. Weather entity for forecasts (e.g., weather.home)
#      - Can be from any weather integration: Met.no, OpenWeatherMap, etc.
#   2. Current temperature sensor (e.g., sensor.outdoor_temperature)
#   3. Apparent/feels-like temperature sensor (e.g., sensor.feels_like_temperature)
# ============================================================================

# ============================================================================
# CONFIGURATION
# ============================================================================
# NOTE: Entity IDs are defined in your device YAML file (e.g., halo-v1-79e384.yaml)
# Required substitutions:
#   - weather_entity_id: Your Home Assistant weather entity (e.g., "weather.hhut")
#   - current_temp_sensor: Your temperature sensor (e.g., "sensor.hhut_temperature")
#   - apparent_temp_sensor: Your feels-like sensor (e.g., "sensor.hhut_feels_like")
#   - weather_refresh_interval: Auto-refresh interval in seconds (e.g., "900")

# ============================================================================
# GLOBALS - Lightweight storage for weather data
# ============================================================================
globals:
  # Current weather
  - id: weather_current_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_apparent_temp
    type: float
    restore_value: no
    initial_value: 'NAN'

  - id: weather_current_condition
    type: std::string
    restore_value: no
    initial_value: '""'

  - id: weather_current_humidity
    type: float
    restore_value: no
    initial_value: 'NAN'

  # Forecast arrays (10 days)
  - id: weather_forecast_temp_high
    type: float[10]
    restore_value: no

  - id: weather_forecast_temp_low
    type: float[10]
    restore_value: no

  - id: weather_forecast_condition
    type: std::string[10]
    restore_value: no

  - id: weather_forecast_precip_prob
    type: float[10]
    restore_value: no

  # Hourly forecast arrays (24 hours)
  - id: weather_hourly_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_apparent_temp
    type: float[24]
    restore_value: no

  - id: weather_hourly_condition
    type: std::string[24]
    restore_value: no

  - id: weather_hourly_precip_prob
    type: float[24]
    restore_value: no

  # Tracking
  - id: weather_last_update
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: weather_on_weather_page
    type: bool
    restore_value: no
    initial_value: 'false'

# ============================================================================
# SCRIPTS - Weather data fetching and processing
# ============================================================================
script:
  # Main script to fetch all weather data via HA actions
  - id: fetch_weather_data
    mode: single
    then:
      - logger.log: "Fetching weather data from Home Assistant..."

      # Fetch daily forecast
      - homeassistant.action:
          action: weather.get_forecasts
          capture_response: true
          data:
            entity_id: ${weather_entity_id}
            type: daily
          
          on_success:
            - lambda: |-
                std::string output;
                serializeJsonPretty(response, output);
                ESP_LOGI("weather", "Forecast JSON:\n%s", output.c_str());

                ESP_LOGI("weather", "✓ Daily forecast response received");
                
                // Access the forecast data - response is already the root object
                if (response.containsKey("${weather_entity_id}")) {
                  auto entity_data = response["${weather_entity_id}"];
                  
                  if (entity_data.containsKey("forecast")) {
                    auto forecast_array = entity_data["forecast"];
                    int day_count = std::min((int)forecast_array.size(), 10);
                    ESP_LOGI("weather", "Found %d days of forecast data", day_count);
                    
                    for (int i = 0; i < day_count; i++) {
                      auto day = forecast_array[i];
                      
                      if (day.containsKey("temperature")) {
                        id(weather_forecast_temp_high)[i] = day["temperature"].as<float>();
                      }
                      
                      if (day.containsKey("templow")) {
                        id(weather_forecast_temp_low)[i] = day["templow"].as<float>();
                      }
                      
                      if (day.containsKey("condition")) {
                        id(weather_forecast_condition)[i] = day["condition"].as<std::string>();
                      }
                      
                      if (day.containsKey("precipitation_probability")) {
                        id(weather_forecast_precip_prob)[i] = day["precipitation_probability"].as<float>();
                      }
                    }
                    ESP_LOGI("weather", "✓ Daily forecast stored");
                  } else {
                    ESP_LOGW("weather", "No 'forecast' key in daily response");
                  }
                } else {
                  ESP_LOGW("weather", "Entity '${weather_entity_id}' not found in daily response");
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "✗ Daily forecast fetch FAILED");

      # Fetch hourly forecast
      - homeassistant.action:
          action: weather.get_forecasts
          capture_response: true
          data:
            entity_id: ${weather_entity_id}
            type: hourly
          on_success:
            - lambda: |-
                std::string output;
                serializeJsonPretty(response, output);
                ESP_LOGI("weather", "Forecast JSON:\n%s", output.c_str());
    
                ESP_LOGI("weather", "✓ Hourly forecast response received");
                
                if (response.containsKey("${weather_entity_id}")) {
                  auto entity_data = response["${weather_entity_id}"];
                  
                  if (entity_data.containsKey("forecast")) {
                    auto forecast_array = entity_data["forecast"];
                    int hour_count = std::min((int)forecast_array.size(), 24);
                    ESP_LOGI("weather", "Found %d hours of forecast data", hour_count);
                    
                    for (int i = 0; i < hour_count; i++) {
                      auto hour = forecast_array[i];
                      
                      if (hour.containsKey("temperature")) {
                        id(weather_hourly_temp)[i] = hour["temperature"].as<float>();
                      }
                      
                      if (hour.containsKey("apparent_temperature")) {
                        id(weather_hourly_apparent_temp)[i] = hour["apparent_temperature"].as<float>();
                      }
                      
                      if (hour.containsKey("condition")) {
                        id(weather_hourly_condition)[i] = hour["condition"].as<std::string>();
                      }
                      
                      if (hour.containsKey("precipitation_probability")) {
                        id(weather_hourly_precip_prob)[i] = hour["precipitation_probability"].as<float>();
                      }
                    }
                    ESP_LOGI("weather", "✓ Hourly forecast stored");
                  } else {
                    ESP_LOGW("weather", "No 'forecast' key in hourly response");
                  }
                } else {
                  ESP_LOGW("weather", "Entity '${weather_entity_id}' not found in hourly response");
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "✗ Hourly forecast fetch FAILED");

      # Fetch current temperature and apparent temp using template
      - homeassistant.action:
          action: template.render
          data:
            template: "{{ states('${current_temp_sensor}') }}"
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "✓ Current temp response received");
                if (response.containsKey("result")) {
                  std::string temp_str = response["result"].as<std::string>();
                  float temp = atof(temp_str.c_str());
                  if (!isnan(temp)) {
                    id(weather_current_temp) = temp;
                    ESP_LOGD("weather", "Temp: %.1f°F", temp);
                  }
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "✗ Current temp fetch FAILED");

      - homeassistant.action:
          action: template.render
          data:
            template: "{{ states('${apparent_temp_sensor}') }}"
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "✓ Apparent temp response received");
                if (response.containsKey("result")) {
                  std::string temp_str = response["result"].as<std::string>();
                  float temp = atof(temp_str.c_str());
                  if (!isnan(temp)) {
                    id(weather_current_apparent_temp) = temp;
                    ESP_LOGD("weather", "Feels like: %.1f°F", temp);
                  }
                }
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "✗ Apparent temp fetch FAILED");

      - homeassistant.action:
          action: template.render
          data:
            template: "{{ states('${weather_entity_id}') }}"
          capture_response: true
          on_success:
            - lambda: |-
                ESP_LOGI("weather", "✓ Current condition response received");
                if (response.containsKey("result")) {
                  id(weather_current_condition) = response["result"].as<std::string>();
                  ESP_LOGD("weather", "Condition: %s", id(weather_current_condition).c_str());
                }

                // Update timestamp
                id(weather_last_update) = millis();

                ESP_LOGI("weather", "✓ Weather data fetch complete!");
                ESP_LOGI("weather", "Current: %.1f°F (feels like %.1f°F), %s",
                         id(weather_current_temp),
                         id(weather_current_apparent_temp),
                         id(weather_current_condition).c_str());
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "✗ Current condition fetch FAILED");

      # Update the display after fetching data
      - script.execute: update_weather_display

  # Script to update LVGL display with fetched data
  - id: update_weather_display
    mode: single
    then:
      - lvgl.label.update:
          id: lbl_weather_forecast_condition_name
          text: !lambda |-
            if (id(weather_current_condition).empty()) {
              return std::string("Unknown");
            }
            return id(weather_current_condition);

      - lvgl.label.update:
          id: lbl_weather_today_outdoor_temp
          text: !lambda |-
            if (isnan(id(weather_current_temp))) {
              return std::string("--.- °F");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.1f °F", id(weather_current_temp));
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_today_tempap
          text: !lambda |-
            if (isnan(id(weather_current_apparent_temp))) {
              return std::string("--°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "%.0f°", id(weather_current_apparent_temp));
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_forecast_temphi
          text: !lambda |-
            if (isnan(id(weather_forecast_temp_high)[0])) {
              return std::string("H: --°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "H: %.0f°", id(weather_forecast_temp_high)[0]);
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_forecast_templo
          text: !lambda |-
            if (isnan(id(weather_forecast_temp_low)[0])) {
              return std::string("L: --°");
            }
            char buf[16];
            snprintf(buf, sizeof(buf), "L: %.0f°", id(weather_forecast_temp_low)[0]);
            return std::string(buf);

      - lvgl.label.update:
          id: lbl_weather_today_dailyprecipprob
          text: !lambda |-
            if (isnan(id(weather_forecast_precip_prob)[0])) {
              return std::string("Chance: --%");
            }
            char buf[32];
            snprintf(buf, sizeof(buf), "Chance: %.0f%%", id(weather_forecast_precip_prob)[0]);
            return std::string(buf);

      - logger.log: "✓ Weather display labels updated"

# ============================================================================
# BUTTONS - Manual refresh controls
# ============================================================================
# button:
#   - platform: template
#     name: "Refresh Weather"
#     id: btn_refresh_weather
#     on_press:
#       - script.execute: fetch_weather_data

#   - platform: template
#     name: "Test Weather Call"
#     id: test_weather_call
#     on_press:
#       - homeassistant.action:
#           action: weather.get_forecasts
#           capture_response: true
#           data:
#             entity_id: weather.hhut
#             type: daily
#           on_success:
#             - lambda: |-
#                 ESP_LOGI("test", "Weather response:");
#                 std::string output;
#                 serializeJsonPretty(response, output);
#                 ESP_LOGI("weather", "%s", output.c_str()); 
#           on_error:
#             - logger.log: "Failed to call weather.get_forecasts!"

#   - platform: template
#     name: "Test example from ESPHome"
#     id: test_example_ESPHome
#     on_press:
#       - homeassistant.action:
#           action: weather.get_forecasts
#           data:
#             entity_id: weather.hhut
#             type: hourly
#           capture_response: true
#           response_template: "{{ response['weather.hhut']['forecast'][0]['temperature'] }}"
#           on_success:
#             - lambda: |-
#                 float temperature = response["response"].as<float>();
#                 ESP_LOGI("weather", "Temperature next hour: %.1f", temperature);

#   - platform: template
#     name: "Test Weather Forecast"
#     id: test_weather_forecast
#     on_press:
#       - homeassistant.action:
#           action: template.render
#           capture_response: true
#           data:
#             # Pulls the full forecast attribute from your weather entity
#             template: >
#               {{ state_attr('weather.hhut', 'forecast') | tojson }}
#           on_success:
#             - lambda: |-
#                 if (response.containsKey("result")) {
#                   // Pretty-print the forecast JSON to logs
#                   std::string forecast_json = response["result"].as<std::string>();
#                   ESP_LOGI("weather", "Forecast attribute JSON:\n%s", forecast_json.c_str());
#                 } else {
#                   ESP_LOGW("weather", "No result key in forecast response!");
#                 }
#           on_error:
#             - lambda: |-
#                 ESP_LOGE("weather", "❌ Forecast fetch FAILED!");
# ============================================================================
# BUTTONS - Manual refresh controls (HA-compatible)
# ============================================================================
button:
  - platform: template
    name: "Refresh Weather"
    id: btn_refresh_weather
    on_press:
      - script.execute: fetch_weather_data

  - platform: template
    name: "Debug Daily Forecast"
    id: btn_debug_daily_forecast
    on_press:
      - homeassistant.action:
          action: weather.get_forecasts
          capture_response: true
          data:
            entity_id: ${weather_entity_id}
            type: daily
          on_success:
            - lambda: |-
                std::string output;
                serializeJsonPretty(response, output);
                ESP_LOGI("weather", "Daily forecast:\n%s", output.c_str());
          on_error:
            - logger.log: "Daily forecast call failed"

  - platform: template
    name: "Test Weather Call"
    id: btn_test_weather_call
    on_press:
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            entity_id: weather.hhut
            type: daily
            return_response: true
          capture_response: true
          on_success:
            - lambda: |-
                // response is JsonObjectConst
                if (!response.containsKey("response")) {
                  ESP_LOGE("weather", "Missing 'response' key!");
                  return;
                }
                const auto &resp_obj = response["response"];
                if (!resp_obj.containsKey("weather.hhut")) {
                  ESP_LOGE("weather", "Missing 'weather.hhut'!");
                  return;
                }
                const auto &entity = resp_obj["weather.hhut"];
                if (!entity.containsKey("forecast")) {
                  ESP_LOGE("weather", "Missing 'forecast'!");
                  return;
                }
                const auto &forecast = entity["forecast"];
                for (size_t i = 0; i < forecast.size(); i++) {
                  const auto &day = forecast[i];
                  float temp = day.containsKey("temperature") ? day["temperature"].as<float>() : NAN;
                  const char *cond = day.containsKey("condition") ? day["condition"].as<std::string>().c_str() : "N/A";
                  ESP_LOGI("weather", "Day %d temp: %.1f, condition: %s", i, temp, cond);
                }
          on_error:
            - logger.log: "Failed to call weather.get_forecasts!"

  - platform: template
    name: "Test example from ESPHome"
    id: btn_test_example
    on_press:
      - homeassistant.action:
          action: weather.get_forecasts
          data:
            entity_id: weather.hhut
            type: hourly
            return_response: true
          capture_response: true
          on_success:
            - lambda: |-
                if (!response.containsKey("response")) return;
                const auto &resp_obj = response["response"];
                if (!resp_obj.containsKey("weather.hhut")) return;
                const auto &entity = resp_obj["weather.hhut"];
                if (!entity.containsKey("forecast")) return;
                const auto &forecast = entity["forecast"];
                if (forecast.size() == 0) return;
                const auto &first_hour = forecast[0];
                float temperature = first_hour.containsKey("temperature") ? first_hour["temperature"].as<float>() : NAN;
                ESP_LOGI("weather", "Temperature next hour: %.1f", temperature);

  - platform: template
    name: "Test Weather Forecast"
    id: btn_test_forecast
    on_press:
      - homeassistant.action:
          action: template.render
          data:
            template: "{{ state_attr('weather.hhut', 'forecast') | tojson }}"
          capture_response: true
          on_success:
            - lambda: |-
                if (!response.containsKey("result")) {
                  ESP_LOGW("weather", "No 'result' key in template response!");
                  return;
                }
                const auto &result = response["result"];
                std::string forecast_json = result.as<std::string>();
                ESP_LOGI("weather", "Forecast attribute JSON:\n%s", forecast_json.c_str());
          on_error:
            - lambda: |-
                ESP_LOGE("weather", "❌ Forecast fetch FAILED!");

# ============================================================================
# INTERVAL - Auto-refresh while on weather page
# ============================================================================
interval:
  # Auto-refresh weather data periodically while viewing weather page
  - interval: ${weather_refresh_interval}s
    then:
      - if:
          condition:
            lambda: 'return id(weather_on_weather_page);'
          then:
            - logger.log: "Auto-refreshing weather data..."
            - script.execute: fetch_weather_data
